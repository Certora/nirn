{
  "language": "Solidity",
  "sources": {
    "contracts/AdapterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IProtocolAdapter.sol\";\nimport \"./interfaces/IAdapterRegistry.sol\";\nimport \"./interfaces/INirnVault.sol\";\nimport \"./libraries/ArrayHelper.sol\";\nimport \"./libraries/DynamicArrays.sol\";\n\n\ncontract AdapterRegistry is Ownable(), IAdapterRegistry {\n  using ArrayHelper for address[];\n  using ArrayHelper for EnumerableSet.AddressSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using DynamicArrays for address[];\n  using DynamicArrays for uint256[];\n\n/* ========== Storage ========== */\n\n  /** @dev Mapping from underlying token to registered vault. */\n  mapping(address => address) public override vaultsByUnderlying;\n\n  /** @dev Accounts allowed to register vaults. */\n  mapping(address => bool) public override approvedVaultFactories;\n\n  /** @dev List of all registered vaults. */\n  EnumerableSet.AddressSet internal vaults;\n\n  /** @dev Number of protocol adapters registered. */\n  uint256 public override protocolsCount;\n\n  /** @dev Mapping from protocol IDs to adapter addresses. */\n  mapping(uint256 => address) public override protocolAdapters;\n\n  /** @dev Mapping from protocol adapter addresses to protocol IDs. */\n  mapping(address => uint256) public override protocolAdapterIds;\n\n  /** @dev Mapping from underlying tokens to lists of adapters. */\n  mapping(address => address[]) internal tokenAdapters;\n\n  /** @dev Mapping from wrapper tokens to adapters. */\n  mapping(address => TokenAdapter) internal adaptersByWrapperToken;\n\n  /** @dev List of all underlying tokens with registered adapters. */\n  EnumerableSet.AddressSet internal supportedTokens;\n\n/* ========== Modifiers ========== */\n\n  modifier onlyProtocolOrOwner {\n    require(protocolAdapterIds[msg.sender] > 0 || msg.sender == owner(), \"!approved\");\n    _;\n  }\n\n  function getProtocolAdapterId(address protocolAdapter) internal view returns (uint256 id) {\n    require((id = protocolAdapterIds[protocolAdapter]) > 0, \"!exists\");\n  }\n\n/* ========== Vault Factory Management ========== */\n\n  function addVaultFactory(address _factory) external override onlyOwner {\n    require(_factory != address(0), \"null address\");\n    require(!approvedVaultFactories[_factory], \"already approved\");\n    approvedVaultFactories[_factory] = true;\n    emit VaultFactoryAdded(_factory);\n  }\n\n  function removeVaultFactory(address _factory) external override onlyOwner {\n    require(approvedVaultFactories[_factory], \"!approved\");\n    approvedVaultFactories[_factory] = false;\n    emit VaultFactoryRemoved(_factory);\n  }\n\n/* ========== Vault Management ========== */\n\n  function addVault(address vault) external override {\n    require(approvedVaultFactories[msg.sender], \"!approved\");\n    address underlying = INirnVault(vault).underlying();\n    require(vaultsByUnderlying[underlying] == address(0), \"exists\");\n    vaultsByUnderlying[underlying] = vault;\n    vaults.add(vault);\n    emit VaultAdded(underlying, vault);\n  }\n\n  function removeVault(address vault) external override onlyOwner {\n    address underlying = INirnVault(vault).underlying();\n    require(vaultsByUnderlying[underlying] != address(0), \"!exists\");\n    vaultsByUnderlying[underlying] = address(0);\n    vaults.remove(vault);\n    emit VaultRemoved(underlying, vault);\n  }\n\n/* ========== Protocol Adapter Management ========== */\n\n  function addProtocolAdapter(address protocolAdapter) external override onlyProtocolOrOwner returns (uint256 id) {\n    require(protocolAdapter != address(0), \"null\");\n    require(protocolAdapterIds[protocolAdapter] == 0, \"exists\");\n    id = ++protocolsCount;\n    protocolAdapterIds[protocolAdapter] = id;\n    protocolAdapters[id] = protocolAdapter;\n    emit ProtocolAdapterAdded(id, protocolAdapter);\n  }\n\n  function removeProtocolAdapter(address protocolAdapter) external override onlyOwner {\n    uint256 id = getProtocolAdapterId(protocolAdapter);\n    delete protocolAdapterIds[protocolAdapter];\n    delete protocolAdapters[id];\n    emit ProtocolAdapterRemoved(id);\n  }\n\n/* ========== Token Adapter Management ========== */\n\n  function _addTokenAdapter(IErc20Adapter adapter, uint256 id) internal {\n    address underlying = adapter.underlying();\n    address wrapper = adapter.token();\n    require(adaptersByWrapperToken[wrapper].protocolId == 0, \"adapter exists\");\n    if (tokenAdapters[underlying].length == 0) {\n      supportedTokens.add(underlying);\n      emit TokenSupportAdded(underlying);\n    }\n    tokenAdapters[underlying].push(address(adapter));\n    adaptersByWrapperToken[wrapper] = TokenAdapter(address(adapter), uint96(id));\n    emit TokenAdapterAdded(address(adapter), id, underlying, wrapper);\n  }\n\n  function addTokenAdapter(address adapter) external override {\n    uint256 id = getProtocolAdapterId(msg.sender);\n    _addTokenAdapter(IErc20Adapter(adapter), id);\n  }\n\n  function addTokenAdapters(address[] calldata adapters) external override {\n    uint256 id = getProtocolAdapterId(msg.sender);\n    uint256 len = adapters.length;\n    for (uint256 i = 0; i < len; i++) {\n      IErc20Adapter adapter = IErc20Adapter(adapters[i]);\n      _addTokenAdapter(adapter, id);\n    }\n  }\n\n  function removeTokenAdapter(address adapter) external override {\n    address wrapper = IErc20Adapter(adapter).token();\n    TokenAdapter memory adapterRecord = adaptersByWrapperToken[wrapper];\n    require(adapterRecord.adapter == address(adapter), \"wrong adapter\");\n    uint256 protocolId = adapterRecord.protocolId;\n    require(\n      msg.sender == owner() ||\n      msg.sender == protocolAdapters[protocolId],\n      \"!authorized\"\n    );\n    delete adaptersByWrapperToken[wrapper];\n    address underlying = IErc20Adapter(adapter).underlying();\n    address[] storage adapters = tokenAdapters[underlying];\n    uint256 index = adapters.indexOf(address(adapter));\n    adapters.remove(index);\n    if (adapters.length == 0) {\n      supportedTokens.remove(underlying);\n      emit TokenSupportRemoved(underlying);\n    }\n    emit TokenAdapterRemoved(address(adapter), protocolId, underlying, wrapper);\n  }\n\n/* ========== Vault Queries ========== */\n\n  function getVaultsList() external view override returns (address[] memory) {\n    return vaults.toArray();\n  }\n\n  function haveVaultFor(address underlying) external view override returns (bool) {\n    return vaultsByUnderlying[underlying] != address(0);\n  }\n\n/* ========== Protocol Queries ========== */\n\n  function getProtocolAdaptersAndIds() external view override returns (address[] memory adapters, uint256[] memory ids) {\n    uint256 len = protocolsCount;\n    adapters = DynamicArrays.dynamicAddressArray(len);\n    ids = DynamicArrays.dynamicUint256Array(len);\n    for (uint256 id = 1; id <= len; id++) {\n      address adapter = protocolAdapters[id];\n      if (adapter != address(0)) {\n        adapters.dynamicPush(adapter);\n        ids.dynamicPush(id);\n      }\n    }\n  }\n\n  function getProtocolMetadata(uint256 id) external view override returns (address protocolAdapter, string memory name) {\n    protocolAdapter = protocolAdapters[id];\n    require(protocolAdapter != address(0), \"invalid id\");\n    name = IProtocolAdapter(protocolAdapter).protocol();\n  }\n\n  function getProtocolForTokenAdapter(address adapter) external view override returns (address protocolAdapter) {\n    address wrapper = IErc20Adapter(adapter).token();\n    TokenAdapter memory adapterRecord = adaptersByWrapperToken[wrapper];\n    require(adapterRecord.adapter == adapter, \"!approved\");\n    protocolAdapter = protocolAdapters[adapterRecord.protocolId];\n  }\n\n/* ========== Supported Token Queries ========== */\n\n  function isSupported(address underlying) external view override returns (bool) {\n    return tokenAdapters[underlying].length > 0;\n  }\n\n  function getSupportedTokens() external view override returns (address[] memory list) {\n    list = supportedTokens.toArray();\n  }\n\n/* ========== Token Adapter Queries ========== */\n\n  function isApprovedAdapter(address adapter) external view override returns (bool) {\n    address wrapper = IErc20Adapter(adapter).token();\n    TokenAdapter memory adapterRecord = adaptersByWrapperToken[wrapper];\n    return adapterRecord.adapter == adapter;\n  }\n\n  function getAdaptersList(address underlying) public view override returns (address[] memory list) {\n    list = tokenAdapters[underlying];\n  }\n\n  function getAdapterForWrapperToken(address wrapperToken) external view override returns (address) {\n    return adaptersByWrapperToken[wrapperToken].adapter;\n  }\n\n  function getAdaptersCount(address underlying) external view override returns (uint256) {\n    return tokenAdapters[underlying].length;\n  }\n\n  function getAdaptersSortedByAPR(address underlying)\n    public\n    view\n    override\n    returns (address[] memory adapters, uint256[] memory aprs)\n  {\n    adapters = getAdaptersList(underlying);\n    uint256 len = adapters.length;\n    aprs = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      try IErc20Adapter(adapters[i]).getAPR() returns (uint256 apr) {\n        aprs[i] = apr;\n      } catch {\n        aprs[i] = 0;\n      }\n    }\n    adapters.sortByDescendingScore(aprs);\n  }\n\n  function getAdaptersSortedByAPRWithDeposit(\n    address underlying,\n    uint256 deposit,\n    address excludingAdapter\n  )\n    public\n    view\n    override\n    returns (address[] memory adapters, uint256[] memory aprs)\n  {\n    adapters = getAdaptersList(underlying);\n    uint256 len = adapters.length;\n    aprs = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      address adapter = adapters[i];\n      if (adapter == excludingAdapter) {\n        try IErc20Adapter(adapter).getAPR() returns (uint256 apr) {\n          aprs[i] = apr;\n        } catch {\n          aprs[i] = 0;\n        }\n      } else {\n        try IErc20Adapter(adapter).getHypotheticalAPR(int256(deposit)) returns (uint256 apr) {\n          aprs[i] = apr;\n        } catch {\n          aprs[i] = 0;\n        }\n      }\n    }\n    adapters.sortByDescendingScore(aprs);\n  }\n\n  function getAdapterWithHighestAPR(address underlying) external view override returns (address adapter, uint256 apr) {\n    (address[] memory adapters, uint256[] memory aprs) = getAdaptersSortedByAPR(underlying);\n    adapter = adapters[0];\n    apr = aprs[0];\n  }\n\n  function getAdapterWithHighestAPRForDeposit(\n    address underlying,\n    uint256 deposit,\n    address excludingAdapter\n  ) external view override returns (address adapter, uint256 apr) {\n    (address[] memory adapters, uint256[] memory aprs) = getAdaptersSortedByAPRWithDeposit(\n      underlying,\n      deposit,\n      excludingAdapter\n    );\n    adapter = adapters[0];\n    apr = aprs[0];\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/interfaces/ITokenAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n\ninterface IErc20Adapter {\n/* ========== Metadata ========== */\n\n  function underlying() external view returns (address);\n\n  function token() external view returns (address);\n\n  function name() external view returns (string memory);\n\n  function availableLiquidity() external view returns (uint256);\n\n/* ========== Conversion ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) external view returns (uint256);\n\n  function toWrappedAmount(uint256 underlyingAmount) external view returns (uint256);\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() external view returns (uint256);\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view returns (uint256);\n\n  function getRevenueBreakdown()\n    external\n    view\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    );\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceWrapped() external view returns (uint256);\n\n  function balanceUnderlying() external view returns (uint256);\n\n/* ========== Interactions ========== */\n\n  function deposit(uint256 amountUnderlying) external returns (uint256 amountMinted);\n\n  function withdraw(uint256 amountToken) external returns (uint256 amountReceived);\n\n  function withdrawAll() external returns (uint256 amountReceived);\n\n  function withdrawUnderlying(uint256 amountUnderlying) external returns (uint256 amountBurned);\n\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external returns (uint256 amountReceived);\n}\n\ninterface IEtherAdapter is IErc20Adapter {\n  function depositETH() external payable returns (uint256 amountMinted);\n\n  function withdrawAsETH(uint256 amountToken) external returns (uint256 amountReceived);\n\n  function withdrawAllAsETH() external returns (uint256 amountReceived);\n\n  function withdrawUnderlyingAsETH(uint256 amountUnderlying) external returns (uint256 amountBurned); \n}"
    },
    "contracts/interfaces/IProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.10;\nimport \"./IAdapterRegistry.sol\";\n\n\ninterface IProtocolAdapter {\n  event MarketFrozen(address token);\n\n  event MarketUnfrozen(address token);\n\n  event AdapterFrozen(address adapter);\n\n  event AdapterUnfrozen(address adapter);\n\n  function registry() external view returns (IAdapterRegistry);\n\n  function frozenAdapters(uint256 index) external view returns (address);\n\n  function frozenTokens(uint256 index) external view returns (address);\n\n  function totalMapped() external view returns (uint256);\n\n  function protocol() external view returns (string memory);\n\n  function getUnmapped() external view returns (address[] memory tokens);\n\n  function getUnmappedUpTo(uint256 max) external view returns (address[] memory tokens);\n\n  function map(uint256 max) external;\n\n  function unfreezeAdapter(uint256 index) external;\n\n  function unfreezeToken(uint256 index) external;\n\n  function freezeAdapter(address adapter) external;\n}"
    },
    "contracts/interfaces/IAdapterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n\ninterface IAdapterRegistry {\n/* ========== Events ========== */\n\n  event ProtocolAdapterAdded(uint256 protocolId, address protocolAdapter);\n\n  event ProtocolAdapterRemoved(uint256 protocolId);\n\n  event TokenAdapterAdded(address adapter, uint256 protocolId, address underlying, address wrapper);\n\n  event TokenAdapterRemoved(address adapter, uint256 protocolId, address underlying, address wrapper);\n\n  event TokenSupportAdded(address underlying);\n\n  event TokenSupportRemoved(address underlying);\n\n  event VaultFactoryAdded(address factory);\n\n  event VaultFactoryRemoved(address factory);\n\n  event VaultAdded(address underlying, address vault);\n\n  event VaultRemoved(address underlying, address vault);\n\n/* ========== Structs ========== */\n\n  struct TokenAdapter {\n    address adapter;\n    uint96 protocolId;\n  }\n\n/* ========== Storage ========== */\n\n  function protocolsCount() external view returns (uint256);\n\n  function protocolAdapters(uint256 id) external view returns (address protocolAdapter);\n\n  function protocolAdapterIds(address protocolAdapter) external view returns (uint256 id);\n\n  function vaultsByUnderlying(address underlying) external view returns (address vault);\n\n  function approvedVaultFactories(address factory) external view returns (bool approved);\n\n/* ========== Vault Factory Management ========== */\n\n  function addVaultFactory(address _factory) external;\n\n  function removeVaultFactory(address _factory) external;\n\n/* ========== Vault Management ========== */\n\n  function addVault(address vault) external;\n\n  function removeVault(address vault) external;\n\n/* ========== Protocol Adapter Management ========== */\n\n  function addProtocolAdapter(address protocolAdapter) external returns (uint256 id);\n\n  function removeProtocolAdapter(address protocolAdapter) external;\n\n/* ========== Token Adapter Management ========== */\n\n  function addTokenAdapter(address adapter) external;\n\n  function addTokenAdapters(address[] calldata adapters) external;\n\n  function removeTokenAdapter(address adapter) external;\n\n/* ========== Vault Queries ========== */\n\n  function getVaultsList() external view returns (address[] memory);\n\n  function haveVaultFor(address underlying) external view returns (bool);\n\n/* ========== Protocol Queries ========== */\n\n  function getProtocolAdaptersAndIds() external view returns (address[] memory adapters, uint256[] memory ids);\n\n  function getProtocolMetadata(uint256 id) external view returns (address protocolAdapter, string memory name);\n\n  function getProtocolForTokenAdapter(address adapter) external view returns (address protocolAdapter);\n\n/* ========== Supported Token Queries ========== */\n\n  function isSupported(address underlying) external view returns (bool);\n\n  function getSupportedTokens() external view returns (address[] memory list);\n\n/* ========== Token Adapter Queries ========== */\n\n  function isApprovedAdapter(address adapter) external view returns (bool);\n\n  function getAdaptersList(address underlying) external view returns (address[] memory list);\n\n  function getAdapterForWrapperToken(address wrapperToken) external view returns (address);\n\n  function getAdaptersCount(address underlying) external view returns (uint256);\n\n  function getAdaptersSortedByAPR(address underlying)\n    external\n    view\n    returns (address[] memory adapters, uint256[] memory aprs);\n\n  function getAdaptersSortedByAPRWithDeposit(\n    address underlying,\n    uint256 deposit,\n    address excludingAdapter\n  )\n    external\n    view\n    returns (address[] memory adapters, uint256[] memory aprs);\n\n  function getAdapterWithHighestAPR(address underlying) external view returns (address adapter, uint256 apr);\n\n  function getAdapterWithHighestAPRForDeposit(\n    address underlying,\n    uint256 deposit,\n    address excludingAdapter\n  ) external view returns (address adapter, uint256 apr);\n}\n\n"
    },
    "contracts/interfaces/INirnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"./IAdapterRegistry.sol\";\nimport \"./ITokenAdapter.sol\";\nimport \"./IRewardsSeller.sol\";\n\n\ninterface INirnVault {\n/* ========== Events ========== */\n\n  /** @dev Emitted when an adapter is removed and its balance fully withdrawn. */\n  event AdapterRemoved(IErc20Adapter adapter);\n\n  /** @dev Emitted when weights or adapters are updated. */\n  event AllocationsUpdated(IErc20Adapter[] adapters, uint256[] weights);\n\n  /** @dev Emitted when performance fees are claimed. */\n  event FeesClaimed(uint256 underlyingAmount, uint256 sharesMinted);\n\n  /** @dev Emitted when a rebalance happens without allocation changes. */\n  event Rebalanced();\n\n  /** @dev Emitted when max underlying is updated. */\n  event SetMaximumUnderlying(uint256 maxBalance);\n\n  /** @dev Emitted when fee recipient address is set. */\n  event SetFeeRecipient(address feeRecipient);\n\n  /** @dev Emitted when performance fee is set. */\n  event SetPerformanceFee(uint256 performanceFee);\n\n  /** @dev Emitted when reserve ratio is set. */\n  event SetReserveRatio(uint256 reserveRatio);\n\n  /** @dev Emitted when rewards seller contract is set. */\n  event SetRewardsSeller(address rewardsSeller);\n\n  /** @dev Emitted when a deposit is made. */\n  event Deposit(uint256 shares, uint256 underlying);\n\n  /** @dev Emitted when a deposit is made. */\n  event Withdrawal(uint256 shares, uint256 underlying);\n\n/* ========== Initializer ========== */\n\n  function initialize(\n    address _underlying,\n    address _rewardsSeller,\n    address _feeRecipient,\n    address _owner\n  ) external;\n\n/* ========== Config Queries ========== */\n\n  function minimumAPRImprovement() external view returns (uint256);\n\n  function registry() external view returns (IAdapterRegistry);\n\n  function eoaSafeCaller() external view returns (address);\n\n  function underlying() external view returns (address);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);  \n\n  function feeRecipient() external view returns (address);\n\n  function rewardsSeller() external view returns (IRewardsSeller);\n\n  function lockedTokens(address) external view returns (bool);\n\n  function maximumUnderlying() external view returns (uint256);\n\n  function performanceFee() external view returns (uint64);\n\n  function reserveRatio() external view returns (uint64);\n\n  function priceAtLastFee() external view returns (uint128);\n\n/* ========== Admin Actions ========== */\n\n  function setMaximumUnderlying(uint256 _maximumUnderlying) external;\n\n  function setPerformanceFee(uint64 _performanceFee) external;\n\n  function setFeeRecipient(address _feeRecipient) external;\n\n  function setRewardsSeller(IRewardsSeller _rewardsSeller) external;\n\n  function setReserveRatio(uint64 _reserveRatio) external;\n\n/* ========== Balance Queries ========== */\n\n  function balance() external view returns (uint256 sum);\n\n  function reserveBalance() external view returns (uint256);\n\n/* ========== Fee Queries ========== */\n\n  function getPendingFees() external view returns (uint256);\n\n/* ========== Price Queries ========== */\n\n  function getPricePerFullShare() external view returns (uint256);\n\n  function getPricePerFullShareWithFee() external view returns (uint256);\n\n/* ========== Reward Token Sales ========== */\n\n  function sellRewards(address rewardsToken, bytes calldata params) external;\n\n/* ========== Adapter Queries ========== */\n\n  function getBalances() external view returns (uint256[] memory balances);\n\n  function getAdaptersAndWeights() external view returns (\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights\n  );\n\n/* ========== Liquidity Delta Queries ========== */\n\n  function getCurrentLiquidityDeltas() external view returns (int256[] memory liquidityDeltas);\n  \n  function getHypotheticalLiquidityDeltas(\n    uint256[] calldata proposedWeights\n  ) external view returns (int256[] memory liquidityDeltas);\n  \n  function getHypotheticalLiquidityDeltas(\n    IErc20Adapter[] calldata proposedAdapters,\n    uint256[] calldata proposedWeights\n  ) external view returns (int256[] memory liquidityDeltas);\n\n/* ========== APR Queries ========== */\n\n  function getAPR() external view returns (uint256);\n\n  function getAPRs() external view returns (uint256[] memory aprs);\n\n  function getHypotheticalAPR(uint256[] memory proposedWeights) external view returns (uint256);\n\n  function getHypotheticalAPR(\n    IErc20Adapter[] calldata proposedAdapters,\n    uint256[] calldata proposedWeights\n  ) external view returns (uint256);\n\n/* ========== Deposit/Withdraw ========== */\n\n  function deposit(uint256 amount) external returns (uint256 shares);\n\n  function depositTo(uint256 amount, address to) external returns (uint256 shares);\n\n  function withdraw(uint256 shares) external returns (uint256 owed);\n\n  function withdrawUnderlying(uint256 amount) external returns (uint256 shares);\n\n/* ========== Rebalance Actions ========== */\n\n  function rebalance() external;\n\n  function rebalanceWithNewWeights(uint256[] calldata proposedWeights) external;\n\n  function rebalanceWithNewAdapters(\n    IErc20Adapter[] calldata proposedAdapters,\n    uint256[] calldata proposedWeights\n  ) external;\n}"
    },
    "contracts/libraries/ArrayHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../libraries/LowGasSafeMath.sol\";\nimport \"../interfaces/ITokenAdapter.sol\";\n\n\nlibrary ArrayHelper {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using LowGasSafeMath for uint256;\n\n/* ========== Type Cast ========== */\n\n  /**\n   * @dev Cast an enumerable address set as an address array.\n   * The enumerable set library stores the values as a bytes32 array, this function\n   * casts it as an address array with a pointer assignment.\n   */\n  function toArray(EnumerableSet.AddressSet storage set) internal view returns (address[] memory arr) {\n    bytes32[] memory bytes32Arr = set._inner._values;\n    assembly { arr := bytes32Arr }\n  }\n\n  /**\n   * @dev Cast an array of IErc20Adapter to an array of address using a pointer assignment.\n   * Note: The resulting array is the same as the original, so all changes to one will be\n   * reflected in the other.\n   */\n  function toAddressArray(IErc20Adapter[] memory _arr) internal pure returns (address[] memory arr) {\n    assembly { arr := _arr }\n  }\n\n/* ========== Math ========== */\n\n  /**\n   * @dev Computes the sum of a uint256 array.\n   */\n  function sum(uint256[] memory arr) internal pure returns (uint256 _sum) {\n    uint256 len = arr.length;\n    for (uint256 i; i < len; i++) _sum = _sum.add(arr[i]);\n  }\n\n/* ========== Removal ========== */\n\n  /**\n   * @dev Remove the element at `index` from an array and decrement its length.\n   * If `index` is the last index in the array, pops it from the array.\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\n   */\n  function mremove(uint256[] memory arr, uint256 index) internal pure {\n    uint256 len = arr.length;\n    if (index != len - 1) {\n      uint256 last = arr[len - 1];\n      arr[index] = last;\n    }\n    assembly { mstore(arr, sub(len, 1)) }\n  }\n\n  /**\n   * @dev Remove the element at `index` from an array and decrement its length.\n   * If `index` is the last index in the array, pops it from the array.\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\n   */\n  function mremove(address[] memory arr, uint256 index) internal pure {\n    uint256 len = arr.length;\n    if (index != len - 1) {\n      address last = arr[len - 1];\n      arr[index] = last;\n    }\n    assembly { mstore(arr, sub(len, 1)) }\n  }\n\n  /**\n   * @dev Remove the element at `index` from an array and decrement its length.\n   * If `index` is the last index in the array, pops it from the array.\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\n   */\n  function mremove(IErc20Adapter[] memory arr, uint256 index) internal pure {\n    uint256 len = arr.length;\n    if (index != len - 1) {\n      IErc20Adapter last = arr[len - 1];\n      arr[index] = last;\n    }\n    assembly { mstore(arr, sub(len, 1)) }\n  }\n\n  /**\n   * @dev Remove the element at `index` from an array and decrement its length.\n   * If `index` is the last index in the array, pops it from the array.\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\n   */\n  function remove(bytes32[] storage arr, uint256 index) internal {\n    uint256 len = arr.length;\n    if (index == len - 1) {\n      arr.pop();\n      return;\n    }\n    bytes32 last = arr[len - 1];\n    arr[index] = last;\n    arr.pop();\n  }\n\n  /**\n   * @dev Remove the element at `index` from an array and decrement its length.\n   * If `index` is the last index in the array, pops it from the array.\n   * Otherwise, stores the last element in the array at `index` and then pops the last element.\n   */\n  function remove(address[] storage arr, uint256 index) internal {\n    uint256 len = arr.length;\n    if (index == len - 1) {\n      arr.pop();\n      return;\n    }\n    address last = arr[len - 1];\n    arr[index] = last;\n    arr.pop();\n  }\n\n/* ========== Search ========== */\n\n  /**\n   * @dev Find the index of an address in an array.\n   * If the address is not found, revert.\n   */\n  function indexOf(address[] memory arr, address find) internal pure returns (uint256) {\n    uint256 len = arr.length;\n    for (uint256 i; i < len; i++) if (arr[i] == find) return i;\n    revert(\"element not found\");\n  }\n\n  /**\n   * @dev Determine whether an element is included in an array.\n   */\n  function includes(address[] memory arr, address find) internal pure returns (bool) {\n    uint256 len = arr.length;\n    for (uint256 i; i < len; i++) if (arr[i] == find) return true;\n    return false;\n  }\n\n/* ========== Sorting ========== */\n\n  /**\n   * @dev Given an array of tokens and scores, sort by scores in descending order.\n   * Maintains the relationship between elements of each array at the same index.\n   */\n  function sortByDescendingScore(\n    address[] memory addresses,\n    uint256[] memory scores\n  ) internal pure {\n    uint256 len = addresses.length;\n    for (uint256 i = 0; i < len; i++) {\n      uint256 score = scores[i];\n      address _address = addresses[i];\n      uint256 j = i - 1;\n      while (int(j) >= 0 && scores[j] < score) {\n        scores[j + 1] = scores[j];\n        addresses[j + 1] = addresses[j];\n        j--;\n      }\n      scores[j + 1] = score;\n      addresses[j + 1] = _address;\n    }\n  }\n}"
    },
    "contracts/libraries/DynamicArrays.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0;\n\n/**\n * @dev Library for handling dynamic in-memory arrays.\n *\n * There is a very good reason for Solidity not supporting this by default -- dynamic\n * arrays in memory completely break memory management for Solidity when used improperly;\n * however, they can be created manually in a safe way so long as the maximum size is known\n * beforehand.\n *\n * This applies primarily to situations where a subset is taken from an existing array\n * by some filtering process.\n *\n * This library should not be used to bypass Solidity's lack of dynamic memory array\n * support in any situation where the code could potentially cause the array to exceed\n * the maximum size assigned in the array creation call. Doing so is likely to have\n * unintended and unpredictable side effects.\n */\nlibrary DynamicArrays {\n  /**\n   * @dev Reserves space in memory for an array of length `size`, but sets the length to 0.\n   * This can be safely used for a dynamic array so long as the maximum possible size is\n   * known beforehand. If the array can exceed `size`, pushing to it will corrupt memory.\n   */\n  function dynamicAddressArray(uint256 size) internal pure returns (address[] memory arr) {\n    arr = new address[](size);\n    assembly { mstore(arr, 0) }\n  }\n\n  /**\n   * @dev Reserves space in memory for an array of length `size`, but sets the length to 0.\n   * This can be safely used for a dynamic array so long as the maximum possible size is\n   * known beforehand. If the array can exceed length `size`, pushing to it will corrupt memory.\n   */\n  function dynamicUint256Array(uint256 size) internal pure returns (uint256[] memory arr) {\n    arr = new uint256[](size);\n    assembly { mstore(arr, 0) }\n  }\n\n  /**\n   * @dev Pushes an address to an in-memory array by reassigning the array length and storing\n   * the element in the position used by solidity for the current array index.\n   * Note: This should ONLY be used on an array created with `dynamicAddressArray`. Using it\n   * on a typical array created with `new address[]()` will almost certainly have unintended\n   * and unpredictable side effects.\n   */\n  function dynamicPush(address[] memory arr, address element) internal pure {\n    assembly {\n      let size := mload(arr)\n      let ptr := add(\n        add(arr, 32),\n        mul(size, 32)\n      )\n      mstore(ptr, element)\n      mstore(arr, add(size, 1))\n    }\n  }\n\n  /**\n   * @dev Pushes a uint256 to an in-memory array by reassigning the array length and storing\n   * the element in the position used by solidity for the current array index.\n   * Note: This should ONLY be used on an array created with `dynamicUint256Array`. Using it\n   * on a typical array created with `new uint256[]()` will almost certainly have unintended\n   * and unpredictable side effects.\n   */\n  function dynamicPush(uint256[] memory arr, uint256 element) internal pure {\n    assembly {\n      let size := mload(arr)\n      let ptr := add(\n        add(arr, 32),\n        mul(size, 32)\n      )\n      mstore(ptr, element)\n      mstore(arr, add(size, 1))\n    }\n  }\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IRewardsSeller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n\ninterface IRewardsSeller {\n  /**\n   * @dev Sell `rewardsToken` for `underlyingToken`.\n   * Should only be called after `rewardsToken` is transferred.\n   * @param sender - Address of account that initially triggered the call. Can be used to restrict who can trigger a sale.\n   * @param rewardsToken - Address of the token to sell.\n   * @param underlyingToken - Address of the token to buy.\n   * @param params - Any additional data that the caller provided.\n   */\n  function sellRewards(\n    address sender,\n    address rewardsToken,\n    address underlyingToken,\n    bytes calldata params\n  ) external;\n}"
    },
    "contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/LowGasSafeMath.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash b83fcf497e895ae59b97c9d04e997023f69b5e97.\n\nSubject to the GPL-2.0 license\n*************************************************************************************************/\n\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n  /// @notice Returns x + y, reverts if sum overflows uint256\n  /// @param x The augend\n  /// @param y The addend\n  /// @return z The sum of x and y\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require((z = x + y) >= x);\n  }\n\n  /// @notice Returns x + y, reverts if sum overflows uint256\n  /// @param x The augend\n  /// @param y The addend\n  /// @return z The sum of x and y\n  function add(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n    require((z = x + y) >= x, errorMessage);\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @return z The difference of x and y\n  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require(y <= x);\n    z = x - y;\n  }\n\n  /// @notice Returns x - y, reverts if underflows\n  /// @param x The minuend\n  /// @param y The subtrahend\n  /// @return z The difference of x and y\n  function sub(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n    require(y <= x, errorMessage);\n    z = x - y;\n  }\n\n  /// @notice Returns x * y, reverts if overflows\n  /// @param x The multiplicand\n  /// @param y The multiplier\n  /// @return z The product of x and y\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    if (x == 0) return 0;\n    z = x * y;\n    require(z / x == y);\n  }\n\n  /// @notice Returns x * y, reverts if overflows\n  /// @param x The multiplicand\n  /// @param y The multiplier\n  /// @return z The product of x and y\n  function mul(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n    if (x == 0) return 0;\n    z = x * y;\n    require(z / x == y, errorMessage);\n  }\n\n  /// @notice Returns ceil(x / y)\n  /// @param x The numerator\n  /// @param y The denominator\n  /// @return z The quotient of x and y\n  function divCeil(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    z = x % y == 0 ? x / y : (x/y) + 1;\n  }\n}\n"
    },
    "contracts/test/TestDynamicArrays.sol": {
      "content": "pragma solidity =0.7.6;\n\nimport \"../libraries/DynamicArrays.sol\";\n\n\ncontract TestDynamicArrays {\n  using DynamicArrays for address[];\n  using DynamicArrays for uint256[];\n\n  function buildDynamicAddressArray(\n    uint256 size,\n    address[] calldata elements\n  ) external pure returns (address[] memory arr) {\n    arr = DynamicArrays.dynamicAddressArray(size);\n    for (uint256 i; i < elements.length; i++) {\n      arr.dynamicPush(elements[i]);\n    }\n  }\n\n  function testOverflowAddressArray() external pure {\n    address[] memory arr = DynamicArrays.dynamicAddressArray(0);\n    bytes memory b = new bytes(0);\n    arr.dynamicPush(address(100));\n    require(b.length == 100, \"Did not overflow as expected\");\n  }\n\n  function buildDynamicUint256Array(\n    uint256 size,\n    uint256[] calldata elements\n  ) external pure returns (uint256[] memory arr) {\n    arr = DynamicArrays.dynamicUint256Array(size);\n    for (uint256 i; i < elements.length; i++) {\n      arr.dynamicPush(elements[i]);\n    }\n  }\n\n  function testOverflowUint256Array() external pure {\n    uint256[] memory arr = DynamicArrays.dynamicUint256Array(0);\n    bytes memory b = new bytes(0);\n    arr.dynamicPush(100);\n    require(b.length == 100, \"Did not overflow as expected\");\n  }\n}"
    },
    "contracts/libraries/AdapterHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"../interfaces/IAdapterRegistry.sol\";\nimport \"../interfaces/ITokenAdapter.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../libraries/LowGasSafeMath.sol\";\nimport \"../libraries/MinimalSignedMath.sol\";\nimport \"../libraries/ArrayHelper.sol\";\nimport \"../libraries/DynamicArrays.sol\";\nimport \"../libraries/Fraction.sol\";\nimport \"../libraries/SafeCast.sol\";\n\n\nlibrary AdapterHelper {\n  using Fraction for uint256;\n  using LowGasSafeMath for uint256;\n  using MinimalSignedMath for int256;\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using ArrayHelper for address[];\n  using ArrayHelper for uint256[];\n  using DynamicArrays for uint256[];\n\n  function packAdapterAndWeight(\n    IErc20Adapter adapter,\n    uint256 weight\n  )\n    internal\n    pure\n    returns (bytes32 encoded)\n  {\n    assembly {\n      encoded := or(shl(96, adapter), weight)\n    }\n  }\n\n  function packAdaptersAndWeights(\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights\n  )\n    internal\n    pure\n    returns (bytes32[] memory encodedArray)\n  {\n    uint256 len = adapters.length;\n    encodedArray = new bytes32[](len);\n    for (uint256 i; i < len; i++) {\n      IErc20Adapter adapter = adapters[i];\n      uint256 weight = weights[i];\n      bytes32 encoded;\n      assembly {\n        encoded := or(shl(96, adapter), weight)\n      }\n      encodedArray[i] = encoded;\n    }\n  }\n\n  function unpackAdapterAndWeight(bytes32 encoded)\n    internal\n    pure\n    returns (\n      IErc20Adapter adapter,\n      uint256 weight\n    )\n  {\n    assembly {\n      adapter := shr(96, encoded)\n      weight := and(\n        encoded,\n        0x0000000000000000000000000000000000000000ffffffffffffffffffffffff\n      )\n    }\n  }\n\n  function unpackAdaptersAndWeights(bytes32[] memory encodedArray)\n    internal\n    pure\n    returns (\n      IErc20Adapter[] memory adapters,\n      uint256[] memory weights\n    )\n  {\n    uint256 len = encodedArray.length;\n    adapters = new IErc20Adapter[](len);\n    weights = new uint256[](len);\n    for (uint256 i; i < len; i++) {\n      bytes32 encoded = encodedArray[i];\n      IErc20Adapter adapter;\n      uint256 weight;\n      assembly {\n        adapter := shr(96, encoded)\n        weight := and(\n          encoded,\n          0x0000000000000000000000000000000000000000ffffffffffffffffffffffff\n        )\n      }\n      adapters[i] = adapter;\n      weights[i] = weight;\n    }\n  }\n\n  function getNetAPR(\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights,\n    int256[] memory liquidityDeltas\n  ) internal view returns (uint256 netAPR) {\n    uint256 len = adapters.length;\n    for (uint256 i; i < len; i++) {\n      uint256 weight = weights[i];\n      if (weight > 0) {\n        netAPR = netAPR.add(\n          adapters[i].getHypotheticalAPR(liquidityDeltas[i]).mulFractionE18(weight)\n        );\n      }\n    }\n  }\n\n  function getLiquidityDeltas(\n    uint256 totalProductiveBalance,\n    uint256[] memory balances,\n    uint256[] memory weights\n  ) internal pure returns (int256[] memory deltas) {\n    uint256 len = balances.length;\n    deltas = new int256[](len);\n    for (uint256 i; i < len; i++) {\n      uint256 targetBalance = totalProductiveBalance.mulFractionE18(weights[i]);\n      deltas[i] = targetBalance.toInt256().sub(balances[i].toInt256());\n    }\n  }\n\n  function getBalances(IErc20Adapter[] memory adapters) internal view returns (uint256[] memory balances) {\n    uint256 len = adapters.length;\n    balances = new uint256[](len);\n    for (uint256 i; i < len; i++) balances[i] = adapters[i].balanceUnderlying();\n  }\n\n  function getExcludedAdapterIndices(\n    IErc20Adapter[] memory oldAdapters,\n    IErc20Adapter[] memory newAdapters\n  ) internal pure returns (uint256[] memory excludedAdapterIndices) {\n    uint256 selfLen = oldAdapters.length;\n    uint256 otherLen = newAdapters.length;\n    excludedAdapterIndices = DynamicArrays.dynamicUint256Array(selfLen);\n    for (uint256 i; i < selfLen; i++) {\n      IErc20Adapter element = oldAdapters[i];\n      for (uint256 j; j < otherLen; j++) {\n        if (element == newAdapters[j]) {\n          element = IErc20Adapter(0);\n          break;\n        }\n      }\n      if (element != IErc20Adapter(0)) {\n        excludedAdapterIndices.dynamicPush(i);\n      }\n    }\n  }\n\n  /**\n   * @dev Rebalances the vault by withdrawing tokens from adapters with negative liquidity deltas\n   * and depositing to adapters with positive liquidity deltas.\n   *\n   * Note: This does not necessarily result in a vault composition that matches the assigned weights,\n   * as some of the lending markets for adapters with negative deltas may have insufficient liquidity\n   * to process withdrawals of the desired amounts. In this case, the vault will withdraw what it can\n   * and deposit up to the amount withdrawn to the other markets.\n   *\n   * Returns an array with indices of the adapters that both have a weight of zero and were able to\n   * process a withdrawal of the vault's full balance. This array is used to remove those adapters.\n   */\n  function rebalance(\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights,\n    int256[] memory liquidityDeltas,\n    uint256 reserveBalance\n  ) internal returns (uint256[] memory removedIndices) {\n    uint256 len = liquidityDeltas.length;\n    removedIndices = DynamicArrays.dynamicUint256Array(len);\n    uint256 totalAvailableBalance = reserveBalance;\n    // Execute withdrawals first\n    for (uint256 i; i < len; i++) {\n      int256 delta = liquidityDeltas[i];\n      if (delta < 0) {\n        uint256 amountToWithdraw = (-delta).toUint256();\n        uint256 amountWithdrawn = adapters[i].withdrawUnderlyingUpTo(amountToWithdraw);\n        // If the weight is 0, `amountToWithdraw` is the balance of the vault in the adapter\n        // and the vault intends to remove the adapter. If the rebalance is able to withdraw\n        // the full balance, it will mark the index of the adapter as able to be removed\n        // so that it can be deleted by the rebalance function.\n        if (weights[i] == 0 && amountWithdrawn == amountToWithdraw) {\n          removedIndices.dynamicPush(i);\n        }\n        totalAvailableBalance = totalAvailableBalance.add(amountWithdrawn);\n      }\n    }\n    // Execute deposits after\n    for (uint256 i; i < len; i++) {\n      int256 delta = liquidityDeltas[i];\n      if (delta > 0) {\n        if (totalAvailableBalance == 0) break;\n        uint256 amountToDeposit = delta.toUint256();\n        if (amountToDeposit >= totalAvailableBalance) {\n          IErc20Adapter(adapters[i]).deposit(totalAvailableBalance);\n          break;\n        }\n        IErc20Adapter(adapters[i]).deposit(amountToDeposit);\n        totalAvailableBalance = totalAvailableBalance.sub(amountToDeposit);\n      }\n    }\n  }\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n\ninterface IERC20 {\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}"
    },
    "contracts/libraries/MinimalSignedMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n\nlibrary MinimalSignedMath {\n  function add(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a + b;\n    require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a - b;\n    require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n    return c;\n  }\n\n  function add(uint256 a, int256 b) internal pure returns (uint256) {\n    require(a < 2**255);\n    int256 _a = int256(a);\n    int256 c = _a + b;\n    require((b >= 0 && c >= _a) || (b < 0 && c < _a));\n    if (c < 0) return 0;\n    return uint256(c);\n  }\n}"
    },
    "contracts/libraries/Fraction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../libraries/LowGasSafeMath.sol\";\n\n\nlibrary Fraction {\n  using LowGasSafeMath for uint256;\n\n  uint256 internal constant ONE_E18 = 1e18;\n\n  function mulFractionE18(uint256 a, uint256 fraction) internal pure returns (uint256) {\n    return a.mul(fraction) / ONE_E18;\n  }\n\n  function mulSubFractionE18(uint256 a, uint256 fraction) internal pure returns (uint256) {\n    return a.sub(a.mul(fraction) / ONE_E18);\n  }\n\n  function toFractionE18(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a.mul(ONE_E18) / b;\n  }\n}"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/SafeCast.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash b83fcf497e895ae59b97c9d04e997023f69b5e97.\n\nSubject to the GPL-2.0 license\n*************************************************************************************************/\n\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n  /// @notice Cast a uint256 to a uint160, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint160\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\n    require((z = uint160(y)) == y);\n  }\n\n  /// @notice Cast a uint256 to a uint128, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint128\n  function toUint128(uint256 y) internal pure returns (uint128 z) {\n    require((z = uint128(y)) == y);\n  }\n\n  /// @notice Cast a int256 to a int128, revert on overflow or underflow\n  /// @param y The int256 to be downcasted\n  /// @return z The downcasted integer, now type int128\n  function toInt128(int256 y) internal pure returns (int128 z) {\n    require((z = int128(y)) == y);\n  }\n\n  /// @notice Cast a uint256 to a int256, revert on overflow\n  /// @param y The uint256 to be casted\n  /// @return z The casted integer, now type int256\n  function toInt256(uint256 y) internal pure returns (int256 z) {\n    require(y < 2**255);\n    z = int256(y);\n  }\n\n  /// @notice Cast an int256 to a uint256, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint160\n  function toUint256(int256 y) internal pure returns (uint256 z) {\n    require(y >= 0);\n    z = uint256(y);\n  }\n}\n"
    },
    "contracts/vaults/NirnVaultBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../OwnableProxyImplementation.sol\";\nimport \"../interfaces/IAdapterRegistry.sol\";\nimport \"../interfaces/IRewardsSeller.sol\";\nimport \"../interfaces/INirnVault.sol\";\nimport \"../libraries/LowGasSafeMath.sol\";\nimport \"../libraries/SymbolHelper.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/AdapterHelper.sol\";\nimport \"./ERC20.sol\";\n\n\n/**\n * @dev Base contract defining the constant and storage variables\n * for NirnVault, as well as basic state queries and setters.\n */\nabstract contract NirnVaultBase is ERC20, OwnableProxyImplementation(), INirnVault {\n  using SafeCast for uint256;\n  using TransferHelper for address;\n  using Fraction for uint256;\n  using LowGasSafeMath for uint256;\n  using MinimalSignedMath for uint256;\n  using MinimalSignedMath for int256;\n  using ArrayHelper for uint256[];\n  using ArrayHelper for address[];\n  using ArrayHelper for bytes32[];\n  using ArrayHelper for IErc20Adapter[];\n  using AdapterHelper for bytes32;\n  using AdapterHelper for bytes32[];\n  using AdapterHelper for IErc20Adapter[];\n\n/* ========== Constants ========== */\n\n  /**\n  * @dev Fraction of the current APR of the vault that a proposed rebalance must improve\n  * the net APR by to be accepted, as a fraction of 1e18.\n  * 5e16 means newAPR-currentAPR must be greater than or equal to currentAPR*1.05\n  */\n  uint256 public constant override minimumAPRImprovement = 5e16;\n\n  /** @dev Nirn adapter registry */\n  IAdapterRegistry public immutable override registry;\n\n  /** @dev Address of a contract which can only execute specific functions and only allows EOAs to call. */\n  address public immutable override eoaSafeCaller;\n\n/* ========== Storage ========== */\n\n  /** @dev Underlying asset for the vault. */\n  address public override underlying;\n\n  /** @dev ERC20 name */\n  string public override name;\n\n  /** @dev ERC20 symbol */\n  string public override symbol;\n\n  /** @dev Tokens which can not be sold - wrapper tokens used by the adapters. */\n  mapping(address => bool) public override lockedTokens;\n\n  /** @dev Account that receives performance fees. */\n  address public override feeRecipient;\n\n  /** @dev Address of contract used to sell rewards. */\n  IRewardsSeller public override rewardsSeller;\n\n  /**\n   * @dev Maximum underlying balance that can be deposited.\n   * If zero, no maximum.\n   */\n  uint256 public override maximumUnderlying;\n\n  /** @dev Fee taken on profit as a fraction of 1e18. */\n  uint64 public override performanceFee;\n\n  /** @dev Ratio of underlying token to keep in the vault for cheap withdrawals as a fraction of 1e18. */\n  uint64 public override reserveRatio;\n\n  /** @dev Last price at which fees were taken. */\n  uint128 public override priceAtLastFee;\n\n  /** @dev Tightly packed token adapters encoded as (address,uint96). */\n  bytes32[] internal packedAdaptersAndWeights;\n\n  function getAdaptersAndWeights() public view override returns (\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights\n  ) {\n    (adapters, weights) = packedAdaptersAndWeights.unpackAdaptersAndWeights();\n  }\n\n  function setAdaptersAndWeights(IErc20Adapter[] memory adapters, uint256[] memory weights) internal {\n    emit AllocationsUpdated(adapters, weights);\n    packedAdaptersAndWeights = AdapterHelper.packAdaptersAndWeights(\n      adapters,\n      weights\n    );\n  }\n\n  function removeAdapters(uint256[] memory removeIndices) internal {\n    uint256 len = removeIndices.length;\n    if (len == 0) return;\n    for (uint256 i = len; i > 0; i--) {\n      uint256 rI = removeIndices[i - 1];\n      (IErc20Adapter adapter,) = packedAdaptersAndWeights[rI].unpackAdapterAndWeight();\n      emit AdapterRemoved(adapter);\n      packedAdaptersAndWeights.remove(rI);\n    }\n  }\n\n/* ========== Modifiers ========== */\n\n  /**\n   * @dev Prevents calls from arbitrary contracts.\n   * Caller must be an EOA account or a pre-approved \"EOA-safe\" caller,\n   * meaning a smart contract which can only be called by an EOA and has\n   * a limited set of functions it can call.\n   * This prevents griefing via flash loans that force the vault to use\n   * adapters with low interest rates.\n   */\n  modifier onlyEOA {\n    require(msg.sender == tx.origin || msg.sender == eoaSafeCaller, \"!EOA\");\n    _;\n  }\n\n/* ========== Constructor ========== */\n\n  constructor(address _registry, address _eoaSafeCaller) {\n    registry = IAdapterRegistry(_registry);\n    eoaSafeCaller = _eoaSafeCaller;\n  }\n\n  function initialize(\n    address _underlying,\n    address _rewardsSeller,\n    address _feeRecipient,\n    address _owner\n  ) external override initializer(_owner) {\n    underlying = _underlying;\n    feeRecipient = _feeRecipient;\n    rewardsSeller = IRewardsSeller(_rewardsSeller);\n\n    (address adapter,) = registry.getAdapterWithHighestAPR(_underlying);\n    packedAdaptersAndWeights.push(AdapterHelper.packAdapterAndWeight(IErc20Adapter(adapter), 1e18));\n    beforeAddAdapter(IErc20Adapter(adapter));\n\n    name = SymbolHelper.getPrefixedName(\"Indexed \", _underlying);\n    symbol = SymbolHelper.getPrefixedSymbol(\"n\", _underlying);\n    performanceFee = 1e17;\n    reserveRatio = 1e17;\n    priceAtLastFee = 1e18;\n  }\n\n/* ========== Configuration Controls ========== */\n\n  function setMaximumUnderlying(uint256 _maximumUnderlying) external override onlyOwner {\n    maximumUnderlying = _maximumUnderlying;\n    emit SetMaximumUnderlying(_maximumUnderlying);\n  }\n\n  function setPerformanceFee(uint64 _performanceFee) external override onlyOwner {\n    claimFees(balance(), totalSupply);\n    require(_performanceFee <= 2e17, \"fee > 20%\");\n    performanceFee = _performanceFee;\n    emit SetPerformanceFee(_performanceFee);\n  }\n\n  function setReserveRatio(uint64 _reserveRatio) external override onlyOwner {\n    require(_reserveRatio <= 2e17, \"reserve > 20%\");\n    reserveRatio = _reserveRatio;\n    emit SetReserveRatio(_reserveRatio);\n  }\n\n  function setFeeRecipient(address _feeRecipient) external override onlyOwner {\n    feeRecipient = _feeRecipient;\n    emit SetFeeRecipient(_feeRecipient);\n  }\n\n  function setRewardsSeller(IRewardsSeller _rewardsSeller) external override onlyOwner {\n    rewardsSeller = _rewardsSeller;\n    emit SetRewardsSeller(address(_rewardsSeller));\n  }\n\n/* ========== Reward Token Sale ========== */\n\n  function sellRewards(address rewardsToken, bytes calldata params) external override onlyEOA {\n    uint256 _balance = IERC20(rewardsToken).balanceOf(address(this));\n    require(!lockedTokens[rewardsToken] && rewardsToken != underlying, \"token locked\");\n    IRewardsSeller _rewardsSeller = rewardsSeller;\n    require(address(_rewardsSeller) != address(0), \"null seller\");\n    rewardsToken.safeTransfer(address(_rewardsSeller), _balance);\n    _rewardsSeller.sellRewards(msg.sender, rewardsToken, underlying, params);\n  }\n\n  function withdrawFromUnusedAdapter(IErc20Adapter adapter) external {\n    (IErc20Adapter[] memory adapters,) = getAdaptersAndWeights();\n    require(\n      !adapters.toAddressArray().includes(address(adapter)),\n      \"!unused\"\n    );\n    require(registry.isApprovedAdapter(address(adapter)), \"!approved\");\n    address wrapper = adapter.token();\n    wrapper.safeApproveMax(address(adapter));\n    uint256 bal = adapter.balanceUnderlying();\n    adapter.withdrawUnderlyingUpTo(bal);\n    wrapper.safeUnapprove(address(adapter));\n  }\n\n/* ========== Underlying Balance Queries ========== */\n\n  struct BalanceSheet {\n    uint256[] balances;\n    uint256 reserveBalance;\n    uint256 totalBalance;\n    uint256 totalProductiveBalance;\n  }\n\n  function getBalanceSheet(\n    IErc20Adapter[] memory adapters\n  ) internal view returns (BalanceSheet memory sheet) {\n    sheet.balances = adapters.getBalances();\n    sheet.reserveBalance = reserveBalance();\n    sheet.totalBalance = sheet.balances.sum().add(sheet.reserveBalance);\n    sheet.totalProductiveBalance = sheet.totalBalance.mulSubFractionE18(reserveRatio);\n  }\n\n  /**\n   * @dev Returns the value in `underlying` of the vault's deposits\n   * in each adapter.\n   */\n  function getBalances() public view override returns (uint256[] memory balances) {\n    (IErc20Adapter[] memory adapters,) = getAdaptersAndWeights();\n    return adapters.getBalances();\n  }\n\n  /**\n   * @dev Returns total value of vault in `underlying`\n   */\n  function balance() public view override returns (uint256 sum) {\n    (IErc20Adapter[] memory adapters,) = getAdaptersAndWeights();\n    uint256 len = adapters.length;\n    for (uint256 i; i < len; i++) {\n      sum = sum.add(adapters[i].balanceUnderlying());\n    }\n    sum = sum.add(reserveBalance());\n  }\n\n  /**\n   * @dev Returns current \"reserve\" balance, or balance of `underlying` held by the vault\n   */\n  function reserveBalance() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(address(this));\n  }\n\n/* ========== Fees ========== */\n\n  function calculateFee(uint256 totalBalance, uint256 supply) internal view returns (uint256) {\n    uint256 valueAtLastCollectionPrice = supply.mulFractionE18(priceAtLastFee);\n    if (totalBalance <= valueAtLastCollectionPrice) return 0;\n    uint256 profit = totalBalance.sub(valueAtLastCollectionPrice);\n    return profit.mulFractionE18(performanceFee);\n  }\n\n  function getPendingFees() external view override returns (uint256) {\n    return calculateFee(balance(), totalSupply);\n  }\n\n  function claimFees(uint256 totalBalance, uint256 supply) internal returns (uint256 newSupply) {\n    uint256 totalFees = calculateFee(totalBalance, supply);\n    if (totalFees == 0) return supply;\n    uint256 equivalentShares = totalFees.mul(supply) / totalBalance.sub(totalFees);\n    emit FeesClaimed(totalFees, equivalentShares);\n    _mint(feeRecipient, equivalentShares);\n    newSupply = supply.add(equivalentShares);\n    priceAtLastFee = totalBalance.toFractionE18(newSupply).toUint128();\n  }\n\n  function claimFees() external {\n    claimFees(balance(), totalSupply);\n  }\n\n/* ========== Price Queries ========== */\n\n  function getPricePerFullShare() external view override returns (uint256) {\n    return balance().toFractionE18(totalSupply);\n  }\n\n  function getPricePerFullShareWithFee() external view override returns (uint256) {\n    uint256 totalBalance = balance();\n    uint256 supply = totalSupply;\n    uint256 pendingFees = calculateFee(totalBalance, supply);\n    return totalBalance.sub(pendingFees).toFractionE18(supply);\n  }\n\n/* ========== Update Hooks ========== */\n\n  function beforeAddAdapter(IErc20Adapter adapter) internal {\n    address wrapper = adapter.token();\n    if (IERC20(wrapper).allowance(address(this), address(adapter)) > 0) return;\n    lockedTokens[wrapper] = true;\n    underlying.safeApproveMax(address(adapter));\n    wrapper.safeApproveMax(address(adapter));\n  }\n\n  function beforeAddAdapters(IErc20Adapter[] memory adapters) internal {\n    uint256 len = adapters.length;\n    for (uint256 i; i < len; i++) beforeAddAdapter(adapters[i]);\n  }\n}"
    },
    "contracts/OwnableProxyImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This is a modified implementation of OpenZeppelin's Ownable.sol.\n * The modifications allow the contract to be inherited by a proxy's logic contract.\n * Any owner-only functions on the base implementation will be unusable.\n *\n * By default, the owner account will be a null address which can be set by invoking\n * a function with the `initializer` modifier. The owner can later be changed with\n * {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner. It also makes available the `initializer` modifier, which will set\n * the owner to `msg.sender` the first time the function is invoked, and will\n * revert if the owner has already been set.\n *\n * Note: This contract should only be inherited by proxy implementation contracts\n * where the implementation will only ever be used as the logic address for proxies.\n * The constructor permanently locks the owner of the implementation contract, but the\n * owner of the proxies can be configured by the first caller.\n */\ncontract OwnableProxyImplementation {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {\n    _owner = address(1);\n    emit OwnershipTransferred(address(0), address(1));\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner {\n    require(_owner == msg.sender, \"!owner\");\n    _;\n  }\n\n  /**\n   * @dev Initializes the contract setting `initialOwner` as the initial owner.\n   * Reverts if owner has already been set.\n   */\n  modifier initializer(address initialOwner) {\n    require(_owner == address(0), \"already initialized\");\n    _owner = initialOwner;\n    emit OwnershipTransferred(address(0), initialOwner);\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    // Modified from OZ contract - sets owner to address(1) to prevent\n    // the initializer from being invoked after ownership is revoked.\n    emit OwnershipTransferred(_owner, address(1));\n    _owner = address(1);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"
    },
    "contracts/libraries/SymbolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../interfaces/IERC20Metadata.sol\";\n\n\nlibrary SymbolHelper {\n\n  /**\n   * @dev Returns the index of the lowest bit set in `self`.\n   * Note: Requires that `self != 0`\n   */\n  function lowestBitSet(uint256 self) internal pure returns (uint256 _z) {\n    require (self > 0, \"Bits::lowestBitSet: Value 0 has no bits set\");\n    uint256 _magic = 0x00818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;\n    uint256 val = (self & -self) * _magic >> 248;\n    uint256 _y = val >> 5;\n    _z = (\n      _y < 4\n        ? _y < 2\n          ? _y == 0\n            ? 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100\n            : 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606\n          : _y == 2\n            ? 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707\n            : 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e\n        : _y < 6\n          ? _y == 4\n            ? 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff\n            : 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616\n          : _y == 6\n            ? 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe\n            : 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd\n    );\n    _z >>= (val & 0x1f) << 3;\n    return _z & 0xff;\n  }\n\n  function getSymbol(address token) internal view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSignature(\"symbol()\"));\n    if (!success) return \"UNKNOWN\";\n    if (data.length != 32) return abi.decode(data, (string));\n    uint256 symbol = abi.decode(data, (uint256));\n    if (symbol == 0) return \"UNKNOWN\";\n    uint256 emptyBits = 255 - lowestBitSet(symbol);\n    uint256 size = (emptyBits / 8) + (emptyBits % 8 > 0 ? 1 : 0);\n    assembly { mstore(data, size) }\n    return string(data);\n  }\n\n  function getName(address token) internal view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSignature(\"name()\"));\n    if (!success) return \"UNKNOWN\";\n    if (data.length != 32) return abi.decode(data, (string));\n    uint256 symbol = abi.decode(data, (uint256));\n    if (symbol == 0) return \"UNKNOWN\";\n    uint256 emptyBits = 255 - lowestBitSet(symbol);\n    uint256 size = (emptyBits / 8) + (emptyBits % 8 > 0 ? 1 : 0);\n    assembly { mstore(data, size) }\n    return string(data);\n  }\n\n  function getPrefixedSymbol(string memory prefix, address token) internal view returns (string memory prefixedSymbol) {\n    prefixedSymbol = string(abi.encodePacked(\n      prefix,\n      getSymbol(token)\n    ));\n  }\n\n  function getPrefixedName(string memory prefix, address token) internal view returns (string memory prefixedName) {\n    prefixedName = string(abi.encodePacked(\n      prefix,\n      getName(token)\n    ));\n  }\n}"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash cfedb1f55864dcf8cc0831fdd8ec18eb045b7fd1.\n\nSubject to the MIT license\n*************************************************************************************************/\n\n\nlibrary TransferHelper {\n  function safeApproveMax(address token, address to) internal {\n    safeApprove(token, to, type(uint256).max);\n  }\n\n  function safeUnapprove(address token, address to) internal {\n    safeApprove(token, to, 0);\n  }\n\n  function safeApprove(address token, address to, uint value) internal {\n    // bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"TH:SA\");\n  }\n\n  function safeTransfer(address token, address to, uint value) internal {\n    // bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"TH:ST\");\n  }\n\n  function safeTransferFrom(address token, address from, address to, uint value) internal {\n    // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"TH:STF\");\n  }\n\n  function safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(\"\");\n    require(success, \"TH:STE\");\n  }\n}"
    },
    "contracts/vaults/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../libraries/LowGasSafeMath.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n\ncontract ERC20 is IERC20 {\n  using LowGasSafeMath for uint256;\n\n  mapping(address => uint256) public override balanceOf;\n\n  mapping(address => mapping(address => uint256)) public override allowance;\n\n  uint256 public override totalSupply;\n\n  function transfer(address recipient, uint256 amount) external override returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      msg.sender,\n      allowance[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\n    _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\n    _approve(\n      msg.sender,\n      spender,\n      allowance[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    balanceOf[sender] = balanceOf[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n    balanceOf[recipient] = balanceOf[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    totalSupply = totalSupply.add(amount);\n    balanceOf[account] = balanceOf[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    balanceOf[account] = balanceOf[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n    totalSupply = totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    allowance[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _burnFrom(address account, uint256 amount) internal {\n    _burn(account, amount);\n    _approve(\n      account,\n      msg.sender,\n      allowance[account][msg.sender].sub(amount, \"ERC20: burn amount exceeds allowance\")\n    );\n  }\n}\n"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n\ninterface IERC20Metadata {\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function decimals() external view returns (uint8);\n}\n\n\ninterface IERC20MetadataBytes32 {\n  function name() external view returns (bytes32);\n  function symbol() external view returns (bytes32);\n}"
    },
    "contracts/test/TestVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../vaults/ERC20.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/SymbolHelper.sol\";\n\ncontract TestVault is ERC20 {\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n  using SymbolHelper for address;\n\n  address public underlying;\n  string public name;\n  string public symbol;\n\n  constructor(address _underlying) {\n    underlying = _underlying;\n    name = string(abi.encodePacked(\n      \"Test Vault \",\n      _underlying.getName()\n    ));\n    symbol = string(abi.encodePacked(\n      \"tv\",\n      _underlying.getSymbol()\n    ));\n  }\n\n  function balance() public view returns (uint256) {\n    return IERC20(underlying).balanceOf(address(this));\n  }\n\n  function price() public view returns (uint256) {\n    return balance().mul(1e18) / totalSupply;\n  }\n\n  function deposit(uint256 amount) external returns (uint256 shares) {\n    uint256 bal = balance();\n    underlying.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 supply = totalSupply;\n    shares = supply == 0 ? amount : (amount.mul(supply) / bal);\n    _mint(msg.sender, shares);\n  }\n\n  function withdraw(uint256 shares) external returns (uint256 amount) {\n    uint256 bal = balance();\n    amount = bal.mul(shares) / totalSupply;\n    _burn(msg.sender, shares);\n    underlying.safeTransfer(msg.sender, amount);\n  }\n\n  function withdrawUnderlying(uint256 amount) external returns (uint256 shares) {\n    uint256 bal = balance();\n    shares = amount.mul(totalSupply) / bal;\n    _burn(msg.sender, shares);\n    underlying.safeTransfer(msg.sender, amount);\n  }\n}"
    },
    "contracts/test/TestMapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n  ILendingPoolAddressesProvider as AaveProviderV1,\n  ILendingPoolCore as AaveCoreV1\n} from '../interfaces/AaveV1Interfaces.sol';\nimport {\n  ILendingPoolAddressesProvider as AaveProviderV2,\n  ILendingPool as AavePoolV2\n} from '../interfaces/AaveV2Interfaces.sol';\nimport '../interfaces/CompoundInterfaces.sol';\nimport '../interfaces/FulcrumInterfaces.sol';\nimport { IFusePoolDirectory, IFusePool } from \"../interfaces/FuseInterfaces.sol\";\nimport {ReserveConfigurationLib} from '../libraries/ReserveConfigurationLib.sol';\nimport '../libraries/SymbolHelper.sol';\nimport 'hardhat/console.sol';\n\ncontract TestMapper {\n  using ReserveConfigurationLib for AavePoolV2.ReserveConfigurationMap;\n\n  AaveProviderV1 internal constant AV1 = AaveProviderV1(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n  AaveProviderV2 internal constant AV2 = AaveProviderV2(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\n  IComptroller internal constant COMP = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n  IComptroller internal constant CREAM = IComptroller(0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258);\n  IComptroller internal constant IRON = IComptroller(0xAB1c342C7bf5Ec5F02ADEA1c2270670bCa144CbB);\n  IBZX internal constant BZX = IBZX(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n  address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  IFusePoolDirectory internal constant FUSE = IFusePoolDirectory(0x835482FE0532f169024d5E9410199369aAD5C77E);\n\n  function aaveV1() external view {\n    AaveCoreV1 core = AV1.getLendingPoolCore();\n    address[] memory tokens = core.getReserves();\n    uint256 len = tokens.length;\n    for (uint256 i = 0; i < len; i++) {\n      string memory symbol =\n        tokens[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? 'Ether' : SymbolHelper.getSymbol(tokens[i]);\n      if (core.getReserveIsFreezed(tokens[i])) {\n        console.log('Got Frozen Asset: ', symbol);\n        continue;\n      }\n      console.log(\n        string(\n          abi.encodePacked(\n            \"['\",\n            toAsciiString(tokens[i]),\n            \"', '\",\n            toAsciiString(core.getReserveATokenAddress(tokens[i])),\n            \"', '\",\n            symbol,\n            \"'],\"\n          )\n        )\n      );\n    }\n  }\n\n  function aaveV2() external view {\n    AavePoolV2 pool = AV2.getLendingPool();\n    address[] memory tokens = pool.getReservesList();\n    uint256 len = tokens.length;\n    for (uint256 i = 0; i < len; i++) {\n      string memory symbol =\n        tokens[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? 'ETH' : SymbolHelper.getSymbol(tokens[i]);\n      if (pool.getConfiguration(tokens[i]).isFrozen()) {\n        console.log('Got Frozen Asset: ', symbol);\n        continue;\n      }\n      console.log(\n        string(\n          abi.encodePacked(\n            \"testAdapter(getAddress('0x\",\n            toAsciiString(tokens[i]),\n            \"'), getAddress('0x\",\n            toAsciiString(pool.getReserveData(tokens[i]).aTokenAddress),\n            \"'), '\",\n            symbol,\n            \"');\"\n          )\n        )\n      );\n    }\n  }\n\n  function fuse() external view {\n    IFusePoolDirectory.FusePool[] memory fusePools = FUSE.getAllPools();\n    uint256 len = fusePools.length;\n    for (uint256 i; i < len; i++) {\n      console.log(\"Oracle: \", fusePools[i].comptroller.oracle());\n    }\n  }\n\n  function compound() external view {\n    ICToken[] memory cTokens = COMP.getAllMarkets();\n    uint256 len = cTokens.length;\n\n    for (uint256 i = 0; i < len; i++) {\n      address underlying;\n      ICToken cToken = cTokens[i];\n      try cToken.underlying{gas: 25000}() returns (address _underlying) {\n        underlying = _underlying;\n        if (underlying == address(0)) {\n          underlying = WETH;\n        }\n      } catch {\n        underlying = WETH;\n      }\n      string memory symbol = underlying == WETH ? 'ETH' : SymbolHelper.getSymbol(underlying);\n      if (COMP.mintGuardianPaused(address(cToken))) {\n        console.log(\"Got Frozen Asset: \", symbol);\n        continue;\n      }\n      console.log(\n        string(\n          abi.encodePacked(\n            \"testAdapter(getAddress('0x\",\n            toAsciiString(underlying),\n            \"'), getAddress('0x\",\n            toAsciiString(address(cToken)),\n            \"'), '\",\n            symbol,\n            \"');\"\n          )\n        )\n      );\n    }\n  }\n\n  function cream() external view {\n    ICToken[] memory cTokens = CREAM.getAllMarkets();\n    uint256 len = cTokens.length;\n\n    for (uint256 i = 0; i < len; i++) {\n      address underlying;\n      ICToken cToken = cTokens[i];\n      if (CREAM.mintGuardianPaused(address(cToken))) {\n        continue;\n      }\n      try cToken.underlying{gas: 25000}() returns (address _underlying) {\n        underlying = _underlying;\n        if (underlying == address(0)) {\n          underlying = WETH;\n        }\n      } catch {\n        underlying = WETH;\n      }\n      string memory symbol = underlying == WETH ? 'ETH' : SymbolHelper.getSymbol(underlying);\n      console.log(\n        string(\n          abi.encodePacked(\n            \"testAdapter(getAddress('0x\",\n            toAsciiString(underlying),\n            \"'), getAddress('0x\",\n            toAsciiString(address(cToken)),\n            \"'), '\",\n            symbol,\n            \"');\"\n          )\n        )\n      );\n    }\n  }\n\n  function iron() external view {\n    ICToken[] memory cTokens = IRON.getAllMarkets();\n    uint256 len = cTokens.length;\n\n    for (uint256 i = 0; i < len; i++) {\n      address underlying;\n      ICToken cToken = cTokens[i];\n      if (IRON.mintGuardianPaused(address(cToken))) {\n        continue;\n      }\n      try cToken.underlying{gas: 25000}() returns (address _underlying) {\n        underlying = _underlying;\n        if (underlying == address(0)) {\n          underlying = WETH;\n        }\n      } catch {\n        underlying = WETH;\n      }\n      string memory symbol = underlying == WETH ? 'ETH' : SymbolHelper.getSymbol(underlying);\n      console.log(\n        string(\n          abi.encodePacked(\n            \"testAdapter(getAddress('0x\",\n            toAsciiString(underlying),\n            \"'), getAddress('0x\",\n            toAsciiString(address(cToken)),\n            \"'), '\",\n            symbol,\n            \"');\"\n          )\n        )\n      );\n    }\n  }\n\n  function fulcrum() external view {\n    address[] memory loanPools = BZX.getLoanPoolsList(0, 1e18);\n    uint256 len = loanPools.length;\n    for (uint256 i = 0; i < len; i++) {\n      address loanPool = loanPools[i];\n      address underlying = BZX.loanPoolToUnderlying(loanPool);\n      string memory symbol = underlying == WETH ? 'ETH' : SymbolHelper.getSymbol(underlying);\n      console.log(\n        string(\n          abi.encodePacked(\n            \"testAdapter(getAddress('0x\",\n            toAsciiString(underlying),\n            \"'), getAddress('0x\",\n            toAsciiString(loanPool),\n            \"'), '\",\n            symbol,\n            \"');\"\n          )\n        )\n      );\n    }\n  }\n\n  function toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint256 i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = char(hi);\n      s[2 * i + 1] = char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n}\n"
    },
    "contracts/interfaces/AaveV1Interfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\npragma abicoder v2;\n\n\ninterface IReserveInterestRateStrategy {\n  function calculateInterestRates(\n    address _reserve,\n    uint256 _availableLiquidity,\n    uint256 _totalBorrowsStable,\n    uint256 _totalBorrowsVariable,\n    uint256 _averageStableBorrowRate\n  )\n    external\n    view\n    returns\n  (\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate\n  );\n}\n\n\ninterface ILendingPoolAddressesProvider {\n  function getLendingPoolCore() external view returns (ILendingPoolCore);\n  function getLendingPool() external view returns (ILendingPool);\n}\n\n\ninterface ILendingPool {\n  function deposit(address reserve, uint256 amount, uint16 referralCode) external payable;\n}\n\n\ninterface IAToken {\n  function redeem(uint256 amount) external;\n}\n\n\ninterface ILendingPoolCore {\n  function freezeReserve(address _reserve) external;\n  function getReserves() external view returns (address[] memory);\n  function getReserveIsFreezed(address _reserve) external view returns (bool);\n  function getReserveATokenAddress(address) external view returns (address);\n  function getReserveCurrentLiquidityRate(address token) external view returns (uint256);\n  function getReserveAvailableLiquidity(address token) external view returns (uint256);\n  function getReserveTotalBorrowsStable(address token) external view returns (uint256);\n  function getReserveTotalBorrowsVariable(address token) external view returns (uint256);\n  function getReserveCurrentAverageStableBorrowRate(address token) external view returns (uint256);\n  function getReserveInterestRateStrategyAddress(address token) external view returns (IReserveInterestRateStrategy);\n}"
    },
    "contracts/interfaces/AaveV2Interfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\npragma abicoder v2;\n\n\ninterface ILendingPoolAddressesProvider {\n  function getLendingPool() external view returns (ILendingPool);\n\n  function getPriceOracle() external view returns (IPriceOracle);\n}\n\n\ninterface IVariableDebtToken {\n  function scaledTotalSupply() external view returns (uint256);\n}\n\n\ninterface IReserveInterestRateStrategy {\n  function calculateInterestRates(\n    address reserve,\n    uint256 availableLiquidity,\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 averageStableBorrowRate,\n    uint256 reserveFactor\n  ) external\n    view\n    returns (\n      uint256 liquidityRate,\n      uint256 stableBorrowRate,\n      uint256 variableBorrowRate\n    );\n}\n\n\ninterface IStableDebtToken {\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\n}\n\n\ninterface ILendingPool {\n  struct ReserveConfigurationMap {\n    uint256 data;\n  }\n\n  struct ReserveData {\n    ReserveConfigurationMap configuration;\n    uint128 liquidityIndex;\n    uint128 variableBorrowIndex;\n    uint128 currentLiquidityRate;\n    uint128 currentVariableBorrowRate;\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    address aTokenAddress;\n    IStableDebtToken stableDebtToken;\n    IVariableDebtToken variableDebtToken;\n    IReserveInterestRateStrategy interestRateStrategy;\n    uint8 id;\n  }\n\n  function getReserveNormalizedIncome(address asset) external view returns (uint128);\n\n  function getReserveData(address asset) external view returns (ReserveData memory);\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getConfiguration(address asset) external view returns (ReserveConfigurationMap memory);\n\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external;\n}\n\n\ninterface IAaveDistributionManager {\n  function getAssetData(address asset) external view returns (uint256 index, uint256 emissionPerSecond, uint256 lastUpdateTimestamp);\n\n  function getUserUnclaimedRewards(address account) external view returns (uint256);\n\n  function getRewardsBalance(address[] calldata assets, address user)\n    external\n    view\n    returns (uint256);\n\n  function claimRewards(\n    address[] calldata assets,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n}\n\n\ninterface IPriceOracle {\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n\n\ninterface IStakedAave {\n  function COOLDOWN_SECONDS() external view returns (uint256);\n\n  function stake(address to, uint256 amount) external;\n\n  function redeem(address to, uint256 amount) external;\n\n  function cooldown() external;\n\n  function claimRewards(address to, uint256 amount) external;\n\n  function stakerRewardsToClaim(address account) external view returns (uint256);\n\n  function stakersCooldowns(address account) external view returns (uint256);\n\n  function getTotalRewardsBalance(address staker) external view returns (uint256);\n\n  function getNextCooldownTimestamp(\n    uint256 fromCooldownTimestamp,\n    uint256 amountToReceive,\n    address toAddress,\n    uint256 toBalance\n  ) external returns (uint256);\n}"
    },
    "contracts/interfaces/CompoundInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\npragma abicoder v2;\n\n\ninterface ICToken {\n  function comptroller() external view returns (address);\n  function underlying() external view returns (address);\n  function name() external view returns (string memory);\n  function totalSupply() external view returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function getCash() external view returns (uint256);\n  function totalBorrows() external view returns (uint256);\n  function totalReserves() external view returns (uint256);\n  function reserveFactorMantissa() external view returns (uint256);\n  function exchangeRateCurrent() external returns (uint256);\n  function exchangeRateStored() external view returns (uint256);\n  function accrualBlockNumber() external view returns (uint256);\n  function borrowBalanceStored(address account) external view returns (uint);\n  function interestRateModel() external view returns (IInterestRateModel);\n\n  function balanceOf(address account) external view returns (uint256);\n  function balanceOfUnderlying(address owner) external returns (uint);\n\n  function mint(uint256 mintAmount) external returns (uint256);\n  function mint() external payable;\n  function redeem(uint256 tokenAmount) external returns (uint256);\n  function redeemUnderlying(uint256 underlyingAmount) external returns (uint256);\n  function borrow(uint borrowAmount) external returns (uint);\n\n  // Used to check if a cream market is for an SLP token\n  function sushi() external view returns (address);\n}\n\n\ninterface IInterestRateModel {\n  function getBorrowRate(\n    uint cash,\n    uint borrows,\n    uint reserves\n  ) external view returns (uint);\n\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) external view returns (uint);\n}\n\n\ninterface IComptroller {\n  function admin() external view returns (address);\n  function _setMintPaused(address cToken, bool state) external returns (bool);\n\n  function getAllMarkets() external view returns (ICToken[] memory);\n  function mintGuardianPaused(address cToken) external view returns (bool);\n  function compSpeeds(address cToken) external view returns (uint256);\n  function oracle() external view returns (IPriceOracle);\n  function compAccrued(address) external view returns (uint);\n  function markets(address cToken) external view returns (\n    bool isListed,\n    uint collateralFactorMantissa,\n    bool isComped\n  );\n  function claimComp(address[] memory holders, address[] memory cTokens, bool borrowers, bool suppliers) external;\n  function refreshCompSpeeds() external;\n}\n\n\ninterface IPriceOracle {\n  function getUnderlyingPrice(address cToken) external view returns (uint);\n}"
    },
    "contracts/interfaces/FulcrumInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n\ninterface IBZX {\n  function getLoanPoolsList(uint256 start, uint256 count) external view returns (address[] memory loanPoolsList);\n  function loanPoolToUnderlying(address pool) external view returns (address underlying);\n  function underlyingToLoanPool(address pool) external view returns (IToken underlying);\n  function getLenderInterestData(address lender, address loanToken)\n    external\n    view\n    returns (\n      uint256 interestPaid,\n      uint256 interestPaidDate,\n      uint256 interestOwedPerDay,\n      uint256 interestUnPaid,\n      uint256 interestFeePercent,\n      uint256 principalTotal\n    );\n}\n\n\ninterface IToken {\n  function supplyInterestRate() external view returns (uint256);\n  function totalAssetSupply() external view returns (uint256);\n  function totalSupplyInterestRate(uint256 assetSupply) external view returns (uint256);\n  function nextSupplyInterestRate(uint256 supplyAmount) external view returns (uint256);\n  function mint(address receiver, uint256 amount) external payable returns (uint256 mintAmount);\n  function burn(address receiver, uint256 burnAmount) external returns (uint256 loanAmountPaid);\n  function assetBalanceOf(address _owner) external view returns (uint256 balance);\n  function tokenPrice() external view returns (uint256);\n  function mintWithEther(address receiver) external payable returns (uint256 mintAmount);\n  function burnToEther(address receiver, uint256 burnAmount) external returns (uint256 loanAmountPaid);\n}"
    },
    "contracts/interfaces/FuseInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\npragma abicoder v2;\n\n\ninterface IFusePoolDirectory {\n\tstruct FusePool {\n\t\tstring name;\n\t\taddress creator;\n\t\tIFusePool comptroller;\n\t\tuint256 blockPosted;\n\t\tuint256 timestampPosted;\n\t}\n  function pools(uint256) external view returns (string memory name, address creator, IFusePool comptroller, uint256 blockPosted, uint256 timestampPosted);\n  function getAllPools() external view returns (FusePool[] memory);\n}\n\n\ninterface IFusePool {\n  function enforceWhitelist() external view returns (bool);\n  function getAllMarkets() external view returns (IFToken[] memory);\n  function mintGuardianPaused(address cToken) external view returns (bool);\n  function oracle() external view returns (address);\n}\n\n\ninterface IFToken {\n  function underlying() external view returns (address);\n  function name() external view returns (string memory);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function getCash() external view returns (uint256);\n  function totalBorrows() external view returns (uint256);\n  function totalReserves() external view returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n  function fuseFeeMantissa() external view returns(uint256);\n  function adminFeeMantissa() external view returns(uint256);\n\n  function exchangeRateCurrent() external returns (uint256);\n  function exchangeRateStored() external view returns (uint256);\n\n  function totalFuseFees() external view returns(uint256);\n  function totalAdminFees() external view returns(uint256);\n\n  function interestRateModel() external view returns (IInterestRateModel);\n  function balanceOf(address account) external view returns (uint256);\n  function mint(uint256 mintAmount) external returns (uint256);\n  function mint() external payable returns (uint256);\n  function redeem(uint256 tokenAmount) external returns (uint256);\n  function redeemUnderlying(uint256 underlyingAmount) external returns (uint256);\n}\n\n\ninterface IInterestRateModel {\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) external view returns (uint);\n}"
    },
    "contracts/libraries/ReserveConfigurationLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../interfaces/AaveV2Interfaces.sol\";\n\n\nlibrary ReserveConfigurationLib {\n  uint256 internal constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 constant FROZEN_MASK                  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n  uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n\n  /**\n   * @dev Gets the reserve factor of the reserve\n   * @param self The reserve configuration\n   * @return The reserve factor\n   **/\n  function getReserveFactor(ILendingPool.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n  }\n\n  function isFrozen(ILendingPool.ReserveConfigurationMap memory self)\n    internal\n    pure\n    returns (bool)\n  {\n    return (self.data & ~FROZEN_MASK) != 0;\n  }\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/protocols/AaveV2ProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/AaveV2Interfaces.sol\";\nimport \"../adapters/aave-v2/AaveV2Erc20Adapter.sol\";\nimport \"../adapters/aave-v2/AaveV2EtherAdapter.sol\";\nimport \"../libraries/ReserveConfigurationLib.sol\";\nimport \"./AbstractProtocolAdapter.sol\";\n\n\ncontract AaveV2ProtocolAdapter is AbstractProtocolAdapter {\n  using ReserveConfigurationLib for ILendingPool.ReserveConfigurationMap;\n\n/* ========== Constants ========== */\n\n  ILendingPoolAddressesProvider public constant aave = ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\n  ILendingPool public immutable pool;\n  address public immutable erc20AdapterImplementation;\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) AbstractProtocolAdapter(_registry) {\n    erc20AdapterImplementation = address(new AaveV2Erc20Adapter(aave));\n    pool = aave.getLendingPool();\n  }\n\n/* ========== Internal Actions ========== */\n\n  function deployAdapter(address underlying) internal override returns (address adapter) {\n    address aToken = pool.getReserveData(underlying).aTokenAddress;\n    if (underlying == weth) {\n      adapter = address(new AaveV2EtherAdapter(aave, underlying, aToken));\n    } else {\n      adapter = CloneLibrary.createClone(erc20AdapterImplementation);\n      AaveV2Erc20Adapter(adapter).initialize(underlying, aToken);\n    }\n  }\n\n/* ========== Public Queries ========== */\n\n  function protocol() external pure virtual override returns (string memory) {\n    return \"Aave V2\";\n  }\n\n  function getUnmapped() public view virtual override returns (address[] memory tokens) {\n    tokens = pool.getReservesList();\n    uint256 len = tokens.length;\n    uint256 prevLen = totalMapped;\n    if (len == prevLen) {\n      assembly { mstore(tokens, 0) }\n    } else {\n      assembly {\n        tokens := add(tokens, mul(prevLen, 32))\n        mstore(tokens, sub(len, prevLen))\n      }\n    }\n  }\n\n/* ========== Internal Queries ========== */\n\n  function isAdapterMarketFrozen(address adapter) internal view virtual override returns (bool) {\n    return isTokenMarketFrozen(IErc20Adapter(adapter).underlying());\n  }\n\n  function isTokenMarketFrozen(address underlying) internal view virtual override returns (bool) {\n    return pool.getConfiguration(underlying).isFrozen();\n  }\n}\n\n"
    },
    "contracts/adapters/aave-v2/AaveV2Erc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../../interfaces/AaveV2Interfaces.sol\";\nimport \"../../interfaces/ITokenAdapter.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/SymbolHelper.sol\";\nimport \"../../libraries/RayMul.sol\";\nimport \"../../libraries/ReserveConfigurationLib.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport \"../../libraries/CloneLibrary.sol\";\n\n\ncontract AaveV2Erc20Adapter is IErc20Adapter {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using RayMul for uint256;\n  using SymbolHelper for address;\n  using TransferHelper for address;\n\n/* ========== Constants ========== */\n\n  ILendingPoolAddressesProvider public immutable addressesProvider;\n  address public constant aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n  IAaveDistributionManager internal constant distributor = IAaveDistributionManager(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\n  ILendingPool public immutable pool;\n\n/* ========== Storage ========== */\n\n  address public userModuleImplementation;\n  address public override underlying;\n  address public override token;\n  mapping(address => address) public userModules;\n  // Pre-calculated and stored in the initializer to reduce gas costs in `getRewardsAPR`.\n  uint256 internal _oneUnderlyingToken;\n\n/* ========== Constructor & Initializer ========== */\n\n  constructor(ILendingPoolAddressesProvider _addressesProvider) {\n    addressesProvider = _addressesProvider;\n    pool = _addressesProvider.getLendingPool();\n  }\n\n  function initialize(address _underlying, address _token) public virtual {\n    require(underlying == address(0) && token == address(0), \"initialized\");\n    require(_underlying != address(0) && _token != address(0), \"bad address\");\n    underlying = _underlying;\n    token = _token;\n    userModuleImplementation = address(new AaveV2UserModule(\n      addressesProvider,\n      _underlying,\n      _token\n    ));\n    _oneUnderlyingToken = 10 ** IERC20Metadata(_underlying).decimals();\n  }\n\n/* ========== Metadata ========== */\n\n  function name() external view virtual override returns (string memory) {\n    return string(abi.encodePacked(\n      \"Aave V2 \",\n      bytes(underlying.getSymbol()),\n      \" Adapter\"\n    ));\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(token);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public pure override returns (uint256) {\n    return tokenAmount;\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public pure override returns (uint256) {\n    return underlyingAmount;\n  }\n\n/* ========== User Modules ========== */\n\n  function getOrCreateUserModule() internal returns (AaveV2UserModule) {\n    address module = userModules[msg.sender];\n    if (module == address(0)) {\n      module = (userModules[msg.sender] = CloneLibrary.createClone(userModuleImplementation));\n      AaveV2UserModule(payable(module)).initialize(msg.sender);\n    }\n    return AaveV2UserModule(payable(module));\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getRewardsAPR(uint256 _totalLiquidity) internal view returns (uint256) {\n    address _token = token;\n    (, uint256 emissionsPerSecond,) = distributor.getAssetData(_token);\n    if (emissionsPerSecond == 0) return 0;\n    IPriceOracle oracle = addressesProvider.getPriceOracle();\n    uint256 aavePrice = oracle.getAssetPrice(aave);\n    uint256 underlyingPrice = oracle.getAssetPrice(underlying);\n    if (aavePrice == 0 || underlyingPrice == 0) {\n      return 0;\n    }\n    uint256 underlyingValue = underlyingPrice.mul(_totalLiquidity) / _oneUnderlyingToken;\n    uint256 rewardsValue = aavePrice.mul(emissionsPerSecond.mul(365 days));\n    return rewardsValue / underlyingValue;\n  }\n\n  function getRewardsAPR() external view returns (uint256) {\n    return getRewardsAPR(IERC20(token).totalSupply());\n  }\n\n  function getBaseAPR() internal view returns (uint256) {\n    ILendingPool.ReserveData memory reserve = pool.getReserveData(underlying);\n    return uint256(reserve.currentLiquidityRate) / 1e9;\n  }\n\n  function getAPR() public view virtual override returns (uint256 apr) {\n    return getBaseAPR().add(getRewardsAPR(IERC20(token).totalSupply()));\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\n    address reserve = underlying;\n    ILendingPool.ReserveData memory data = pool.getReserveData(reserve);\n    uint256 _availableLiquidity = IERC20(reserve).balanceOf(data.aTokenAddress).add(liquidityDelta);\n    uint256 totalVariableDebt = data.variableDebtToken.scaledTotalSupply().rayMul(data.variableBorrowIndex);\n    (uint256 totalStableDebt, uint256 avgStableRate) = data.stableDebtToken.getTotalSupplyAndAvgRate();\n    (uint256 liquidityRate, ,) = data.interestRateStrategy.calculateInterestRates(\n      reserve,\n      _availableLiquidity,\n      totalStableDebt,\n      totalVariableDebt,\n      avgStableRate,\n      ReserveConfigurationLib.getReserveFactor(data.configuration)\n    );\n    uint256 newLiquidity = _availableLiquidity.add(totalVariableDebt).add(totalStableDebt);\n    return (liquidityRate / 1e9).add(getRewardsAPR(newLiquidity));\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    override\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    uint256 rewardsAPR = getRewardsAPR(IERC20(token).totalSupply());\n    uint256 size = rewardsAPR > 0 ? 2 : 1;\n    assets = new address[](size);\n    aprs = new uint256[](size);\n    assets[0] = underlying;\n    aprs[0] = getBaseAPR();\n    if (rewardsAPR > 0) {\n      assets[1] = aave;\n      aprs[1] = rewardsAPR;\n    }\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceWrapped() public view virtual override returns (uint256) {\n    address module = userModules[msg.sender];\n    return IERC20(token).balanceOf(module == address(0) ? msg.sender : module);\n  }\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    address module = userModules[msg.sender];\n    return IERC20(token).balanceOf(module == address(0) ? msg.sender : module);\n  }\n\n/* ========== Token Actions ========== */\n\n  function deposit(uint256 amountUnderlying) external virtual override returns (uint256 amountMinted) {\n    require(amountUnderlying > 0, \"deposit 0\");\n    AaveV2UserModule module = getOrCreateUserModule();\n    underlying.safeTransferFrom(msg.sender, address(module), amountUnderlying);\n    module.deposit(amountUnderlying);\n    return amountUnderlying;\n  }\n\n  function withdraw(uint256 amountToken) public virtual override returns (uint256 amountReceived) {\n    require(amountToken > 0, \"withdraw 0\");\n    address module = userModules[msg.sender];\n    if (module == address(0)) {\n      token.safeTransferFrom(msg.sender, address(this), amountToken);\n      pool.withdraw(underlying, amountToken, msg.sender);\n      return amountToken;\n    }\n    AaveV2UserModule(payable(module)).withdraw(amountToken, true);\n    amountReceived = amountToken;\n  }\n\n  function withdrawAll() external virtual override returns (uint256 amountReceived) {\n    return withdraw(balanceWrapped());\n  }\n\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\n    amountBurned = withdraw(amountUnderlying);\n  }\n\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual override returns (uint256 amountReceived) {\n    require(amountUnderlying > 0, \"withdraw 0\");\n    uint256 amountAvailable = availableLiquidity();\n    amountReceived = amountAvailable < amountUnderlying ? amountAvailable : amountUnderlying;\n    withdraw(amountReceived);\n  }\n}\n\n\ncontract AaveV2UserModule {\n  using TransferHelper for address;\n\n  IStakedAave internal constant stkAave = IStakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\n  IAaveDistributionManager internal constant incentives = IAaveDistributionManager(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\n  ILendingPool internal immutable pool;\n  address internal immutable underlying;\n  address internal immutable aToken;\n  address internal immutable adapter;\n\n  address internal user;\n  bool public assetHasRewards;\n  uint32 public cooldownUnlockAt;\n\n  constructor(\n    ILendingPoolAddressesProvider addressesProvider,\n    address _underlying,\n    address _aToken\n  ) {\n    adapter = msg.sender;\n    underlying = _underlying;\n    aToken = _aToken;\n    ILendingPool _pool = addressesProvider.getLendingPool();\n    pool = _pool;\n  }\n\n  function initialize(address _user) external {\n    require(msg.sender == adapter && user == address(0));\n    user = _user;\n    underlying.safeApproveMax(address(pool));\n    (, uint256 emissionPerSecond,) = incentives.getAssetData(aToken);\n    assetHasRewards = emissionPerSecond > 0;\n  }\n\n  function setHasRewards() external {\n    (, uint256 emissionPerSecond,) = incentives.getAssetData(aToken);\n    assetHasRewards = emissionPerSecond > 0;\n  }\n\n  function _claimAndTriggerCooldown() internal {\n    address[] memory assets = new address[](1);\n    assets[0] = aToken;\n    uint256 r = incentives.getUserUnclaimedRewards(address(this));\n    if (r > 0) {\n      incentives.claimRewards(assets, r, address(this));\n      stkAave.cooldown();\n      uint256 cooldownDuration = stkAave.COOLDOWN_SECONDS();\n      cooldownUnlockAt = uint32(block.timestamp + cooldownDuration);\n    }\n  }\n\n  function poke() public {\n    // We do not check if the asset has rewards inside of poke so that if\n    // rewards are accrued and then the asset's incentives are set to zero,\n    // the existing rewards can still be manually claimed.\n    // If there's not a pending cooldown, claim any rewards and begin the cooldown\n    // If there is a pending cooldown:\n    // - If it is over, redeem stkAave, reset the timer, claim stkAave and begin new cooldown\n    // - If it is not over, do nothing\n    if (cooldownUnlockAt > 0) {\n      if (cooldownUnlockAt < block.timestamp) {\n        stkAave.redeem(user, type(uint256).max);\n        cooldownUnlockAt = 0;\n      } else {\n        return;\n      }\n    }\n    _claimAndTriggerCooldown();\n  }\n\n  function deposit(uint256 amount) external {\n    require(msg.sender == adapter, \"!adapter\");\n    pool.deposit(underlying, amount, address(this), 0);\n    if (assetHasRewards) poke();\n  }\n\n  function withdraw(uint256 amount, bool toUser) external {\n    require(msg.sender == adapter, \"!adapter\");\n    pool.withdraw(underlying, amount, toUser ? user : adapter);\n    if (assetHasRewards) poke();\n  }\n}"
    },
    "contracts/adapters/aave-v2/AaveV2EtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./AaveV2Erc20Adapter.sol\";\nimport \"../../interfaces/IWETH.sol\";\n\n\ncontract AaveV2EtherAdapter is IEtherAdapter {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using RayMul for uint256;\n  using SymbolHelper for address;\n  using TransferHelper for address;\n  using TransferHelper for address payable;\n\n/* ========== Constants ========== */\n\n  ILendingPoolAddressesProvider public immutable addressesProvider;\n  address public constant aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n  IAaveDistributionManager internal constant distributor = IAaveDistributionManager(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\n  ILendingPool public immutable pool;\n  address public immutable userModuleImplementation;\n  address public immutable override underlying;\n  address public immutable override token;\n\n/* ========== Storage ========== */\n  mapping(address => address) public userModules;\n\n/* ========== Fallbacks ========== */\n\n  receive() external payable { return; }\n\n/* ========== Constructor & Initializer ========== */\n\n  constructor(\n    ILendingPoolAddressesProvider _addressesProvider,\n    address _underlying,\n    address _token\n  ) {\n    addressesProvider = _addressesProvider;\n    pool = _addressesProvider.getLendingPool();\n    underlying = _underlying;\n    token = _token;\n    userModuleImplementation = address(new AaveV2UserModule(\n      _addressesProvider,\n      _underlying,\n      _token\n    ));\n  }\n\n/* ========== Metadata ========== */\n\n  function name() external view virtual override returns (string memory) {\n    return string(abi.encodePacked(\n      \"Aave V2 \",\n      bytes(underlying.getSymbol()),\n      \" Adapter\"\n    ));\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(token);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public pure override returns (uint256) {\n    return tokenAmount;\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public pure override returns (uint256) {\n    return underlyingAmount;\n  }\n\n/* ========== User Modules ========== */\n\n  function getOrCreateUserModule() internal returns (AaveV2UserModule) {\n    address module = userModules[msg.sender];\n    if (module == address(0)) {\n      module = (userModules[msg.sender] = CloneLibrary.createClone(userModuleImplementation));\n      AaveV2UserModule(payable(module)).initialize(msg.sender);\n    }\n    return AaveV2UserModule(payable(module));\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getRewardsAPR(uint256 _totalLiquidity) internal view returns (uint256) {\n    address _token = token;\n    (, uint256 emissionsPerSecond,) = distributor.getAssetData(_token);\n    if (emissionsPerSecond == 0) return 0;\n    IPriceOracle oracle = addressesProvider.getPriceOracle();\n    uint256 aavePrice = oracle.getAssetPrice(aave);\n    uint256 underlyingPrice = oracle.getAssetPrice(underlying);\n    if (aavePrice == 0 || underlyingPrice == 0) {\n      return 0;\n    }\n    return aavePrice.mul(emissionsPerSecond.mul(365 days)).mul(1e18) / underlyingPrice.mul(_totalLiquidity);\n  }\n\n  function getRewardsAPR() external view returns (uint256) {\n    return getRewardsAPR(IERC20(token).totalSupply());\n  }\n\n  function getBaseAPR() internal view returns (uint256) {\n    ILendingPool.ReserveData memory reserve = pool.getReserveData(underlying);\n    return uint256(reserve.currentLiquidityRate) / 1e9;\n  }\n\n  function getAPR() public view virtual override returns (uint256 apr) {\n    return getBaseAPR().add(getRewardsAPR(IERC20(token).totalSupply()));\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\n    address reserve = underlying;\n    ILendingPool.ReserveData memory data = pool.getReserveData(reserve);\n    uint256 _availableLiquidity = IERC20(reserve).balanceOf(data.aTokenAddress).add(liquidityDelta);\n    uint256 totalVariableDebt = data.variableDebtToken.scaledTotalSupply().rayMul(data.variableBorrowIndex);\n    (uint256 totalStableDebt, uint256 avgStableRate) = data.stableDebtToken.getTotalSupplyAndAvgRate();\n    (uint256 liquidityRate, ,) = data.interestRateStrategy.calculateInterestRates(\n      reserve,\n      _availableLiquidity,\n      totalStableDebt,\n      totalVariableDebt,\n      avgStableRate,\n      ReserveConfigurationLib.getReserveFactor(data.configuration)\n    );\n    uint256 newLiquidity = _availableLiquidity.add(totalVariableDebt).add(totalStableDebt);\n    return (liquidityRate / 1e9).add(getRewardsAPR(newLiquidity));\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    override\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    uint256 rewardsAPR = getRewardsAPR(IERC20(token).totalSupply());\n    uint256 size = rewardsAPR > 0 ? 2 : 1;\n    assets = new address[](size);\n    aprs = new uint256[](size);\n    assets[0] = underlying;\n    aprs[0] = getBaseAPR();\n    if (rewardsAPR > 0) {\n      assets[1] = aave;\n      aprs[1] = rewardsAPR;\n    }\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceWrapped() public view virtual override returns (uint256) {\n    address module = userModules[msg.sender];\n    return IERC20(token).balanceOf(module == address(0) ? msg.sender : module);\n  }\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    address module = userModules[msg.sender];\n    return IERC20(token).balanceOf(module == address(0) ? msg.sender : module);\n  }\n\n/* ========== Token Actions ========== */\n\n  function deposit(uint256 amountUnderlying) external virtual override returns (uint256 amountMinted) {\n    require(amountUnderlying > 0, \"deposit 0\");\n    AaveV2UserModule module = getOrCreateUserModule();\n    underlying.safeTransferFrom(msg.sender, address(module), amountUnderlying);\n    module.deposit(amountUnderlying);\n    return amountUnderlying;\n  }\n\n  function depositETH() external payable virtual override returns (uint256 amountMinted) {\n    require(msg.value > 0, \"deposit 0\");\n    AaveV2UserModule module = getOrCreateUserModule();\n    IWETH(underlying).deposit{value: msg.value}();\n    underlying.safeTransfer(address(module), msg.value);\n    module.deposit(msg.value);\n    return msg.value;\n  }\n\n  function withdraw(uint256 amountToken) public virtual override returns (uint256 amountReceived) {\n    require(amountToken > 0, \"withdraw 0\");\n    address module = userModules[msg.sender];\n    if (module == address(0)) {\n      token.safeTransferFrom(msg.sender, address(this), amountToken);\n      pool.withdraw(underlying, amountToken, msg.sender);\n      return amountToken;\n    }\n    AaveV2UserModule(payable(module)).withdraw(amountToken, true);\n    return amountToken;\n  }\n\n  function withdrawAsETH(uint256 amountToken) public virtual override returns (uint256 amountReceived) {\n    require(amountToken > 0, \"withdraw 0\");\n    address module = userModules[msg.sender];\n    if (module == address(0)) {\n      token.safeTransferFrom(msg.sender, address(this), amountToken);\n      pool.withdraw(underlying, amountToken, address(this));\n    } else {\n      AaveV2UserModule(payable(module)).withdraw(amountToken, false);\n    }\n    IWETH(underlying).withdraw(amountToken);\n    msg.sender.safeTransferETH(amountToken);\n    return amountToken;\n  }\n\n  function withdrawAll() public virtual override returns (uint256 amountReceived) {\n    return withdraw(balanceWrapped());\n  }\n\n  function withdrawAllAsETH() public virtual override returns (uint256 amountReceived) {\n    return withdrawAsETH(balanceWrapped());\n  }\n\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\n    return withdraw(amountUnderlying);\n  }\n\n  function withdrawUnderlyingAsETH(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\n    return withdrawAsETH(amountUnderlying);\n  }\n\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual override returns (uint256 amountReceived) {\n    require(amountUnderlying > 0, \"withdraw 0\");\n    uint256 amountAvailable = availableLiquidity();\n    amountReceived = amountAvailable < amountUnderlying ? amountAvailable : amountUnderlying;\n    withdraw(amountReceived);\n  }\n}"
    },
    "contracts/protocols/AbstractProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IAdapterRegistry.sol\";\nimport \"../libraries/CloneLibrary.sol\";\nimport \"../libraries/ArrayHelper.sol\";\n\n\nabstract contract AbstractProtocolAdapter {\n  using ArrayHelper for address[];\n\n/* ========== Events ========== */\n\n  event MarketFrozen(address token);\n\n  event MarketUnfrozen(address token);\n\n  event AdapterFrozen(address adapter);\n\n  event AdapterUnfrozen(address adapter);\n\n/* ========== Constants ========== */\n\n  /**\n   * @dev WETH address used for deciding whether to deploy an ERC20 or Ether adapter.\n   */\n  address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n  /**\n   * @dev Global registry of adapters.\n   */\n  IAdapterRegistry public immutable registry;\n\n/* ========== Storage ========== */\n\n  /**\n   * @dev List of adapters which have been deployed and then frozen.\n   */\n  address[] public frozenAdapters;\n\n  /**\n   * @dev List of tokens which have been frozen and which do not have an adapter.\n   */\n  address[] public frozenTokens;\n\n  /**\n   * @dev Number of tokens which have been mapped by the adapter.\n   */\n  uint256 public totalMapped;\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) {\n    registry = _registry;\n  }\n\n/* ========== Public Actions ========== */\n\n  /**\n   * @dev Map up to `max` tokens, starting at `totalMapped`.\n   */\n  function map(uint256 max) external virtual {\n    address[] memory tokens = getUnmappedUpTo(max);\n    uint256 len = tokens.length;\n    address[] memory adapters = new address[](len);\n    uint256 skipped;\n    for (uint256 i; i < len; i++) {\n      address token = tokens[i];\n      if (isTokenMarketFrozen(token)) {\n        skipped++;\n        frozenTokens.push(token);\n        emit MarketFrozen(token);\n        continue;\n      }\n      address adapter = deployAdapter(token);\n      adapters[i - skipped] = adapter;\n    }\n    totalMapped += len;\n    assembly { if gt(skipped, 0) { mstore(adapters, sub(len, skipped)) } }\n    registry.addTokenAdapters(adapters);\n  }\n\n  /**\n   * @dev Unfreeze adapter at `index` in `frozenAdapters`.\n   * Market for the adapter must not be frozen by the protocol.\n   */\n  function unfreezeAdapter(uint256 index) external virtual {\n    address adapter = frozenAdapters[index];\n    require(!isAdapterMarketFrozen(adapter), \"Market still frozen\");\n    frozenAdapters.remove(index);\n    registry.addTokenAdapter(adapter);\n    emit AdapterUnfrozen(adapter);\n  }\n\n  /**\n   * @dev Unfreeze token at `index` in `frozenTokens` and create a new adapter for it.\n   * Market for the token must not be frozen by the protocol.\n   */\n  function unfreezeToken(uint256 index) external virtual {\n    address token = frozenTokens[index];\n    require(!isTokenMarketFrozen(token), \"Market still frozen\");\n    frozenTokens.remove(index);\n    address adapter = deployAdapter(token);\n    registry.addTokenAdapter(adapter);\n    emit MarketUnfrozen(token);\n  }\n\n  /**\n   * @dev Freeze `adapter` - add it to `frozenAdapters` and remove it from the registry.\n   * Does not verify adapter exists or has been registered by this contract because the\n   * registry handles that.\n   */\n  function freezeAdapter(address adapter) external virtual {\n    require(isAdapterMarketFrozen(adapter), \"Market not frozen\");\n    frozenAdapters.push(adapter);\n    registry.removeTokenAdapter(adapter);\n    emit AdapterFrozen(adapter);\n  }\n\n/* ========== Internal Actions ========== */\n\n  /**\n   * @dev Deploys an adapter for `token`, which will either be an underlying token\n   * or a wrapper token, whichever is returned by `getUnmapped`.\n   */\n  function deployAdapter(address token) internal virtual returns (address);\n\n/* ========== Public Queries ========== */\n\n  /**\n   * @dev Name of the protocol the adapter is for.\n   */\n  function protocol() external view virtual returns (string memory);\n\n  /**\n   * @dev Get the list of tokens which have not already been mapped by the adapter.\n   * Tokens may be underlying tokens or wrapper tokens for a lending market.\n   */\n  function getUnmapped() public view virtual returns (address[] memory tokens);\n\n  /**\n   * @dev Get up to `max` tokens which have not already been mapped by the adapter.\n   * Tokens may be underlying tokens or wrapper tokens for a lending market.\n   */\n  function getUnmappedUpTo(uint256 max) public view virtual returns (address[] memory tokens) {\n    tokens = getUnmapped();\n    if (tokens.length > max) {\n      assembly { mstore(tokens, max) }\n    }\n  }\n\n  function getFrozenAdapters() external view returns (address[] memory tokens) {\n    tokens = frozenAdapters;\n  }\n\n  function getFrozenTokens() external view returns (address[] memory tokens) {\n    tokens = frozenTokens;\n  }\n\n/* ========== Internal Queries ========== */\n\n  /**\n   * @dev Check whether the market for an adapter is frozen.\n   */\n  function isAdapterMarketFrozen(address adapter) internal view virtual returns (bool);\n\n  /**\n   * @dev Check whether the market for a token is frozen.\n   */\n  function isTokenMarketFrozen(address token) internal view virtual returns (bool);\n}"
    },
    "contracts/libraries/RayMul.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n\nlibrary RayMul {\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant halfRAY = RAY / 2;\n\n  /**\n   * @dev Multiplies two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a*b, in ray\n   **/\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n\n    require(a <= (type(uint256).max - halfRAY) / b, \"rayMul overflow\");\n\n    return (a * b + halfRAY) / RAY;\n  }\n}"
    },
    "contracts/libraries/CloneLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/*\nThe MIT License (MIT)\nCopyright (c) 2018 Murray Software, LLC.\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * EIP 1167 Proxy Deployment\n * Originally from https://github.com/optionality/clone-factory/\n */\nlibrary CloneLibrary {\n  function getCreateCode(address target) internal pure returns (bytes memory createCode) {\n    // Reserve 55 bytes for the deploy code + 17 bytes as a buffer to prevent overwriting\n    // other memory in the final mstore\n    createCode = new bytes(72);\n    assembly {\n      let clone := add(createCode, 32)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), shl(96, target))\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      mstore(createCode, 55)\n    }\n  }\n\n  function createClone(address target) internal returns (address result) {\n    bytes memory createCode = getCreateCode(target);\n    assembly { result := create(0, add(createCode, 32), 55) }\n  }\n\n  function createClone(address target, bytes32 salt) internal returns (address result) {\n    bytes memory createCode = getCreateCode(target);\n    assembly { result := create2(0, add(createCode, 32), 55, salt) }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), shl(96, target))\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n\ninterface IWETH {\n  function deposit() external payable;\n  function withdraw(uint) external;\n}"
    },
    "contracts/protocols/IronBankProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/CompoundInterfaces.sol\";\nimport \"../adapters/ironbank/CyErc20Adapter.sol\";\nimport \"../adapters/ironbank/CyEtherAdapter.sol\";\nimport \"./AbstractProtocolAdapter.sol\";\n\n\ncontract IronBankProtocolAdapter is AbstractProtocolAdapter {\n  using CloneLibrary for address;\n\n/* ========== Constants ========== */\n\n  IComptroller public constant comptroller = IComptroller(0xAB1c342C7bf5Ec5F02ADEA1c2270670bCa144CbB);\n  address public immutable erc20AdapterImplementation;\n  address public immutable etherAdapterImplementation;\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) AbstractProtocolAdapter(_registry) {\n    erc20AdapterImplementation = address(new CyErc20Adapter());\n    etherAdapterImplementation = address(new CyEtherAdapter());\n  }\n\n/* ========== Internal Actions ========== */\n\n  function deployAdapter(address cToken) internal virtual override returns (address adapter) {\n    address underlying;\n    // The call to underlying will use all the gas sent if it fails,\n    // so we specify a maximum of 25k gas. The contract will only use ~2k\n    // but this protects against all likely changes to the gas schedule.\n    try ICToken(cToken).underlying{gas: 25000}() returns (address _underlying) {\n      underlying = _underlying;\n      if (underlying == address(0)) {\n        underlying = weth;\n      }\n    } catch {\n      underlying = weth;\n    }\n    if (underlying == weth) {\n      adapter = CloneLibrary.createClone(etherAdapterImplementation);\n    } else {\n      adapter = CloneLibrary.createClone(erc20AdapterImplementation);\n    }\n    CyErc20Adapter(adapter).initialize(underlying, address(cToken));\n  }\n\n/* ========== Public Queries ========== */\n\n  function protocol() external pure virtual override returns (string memory) {\n    return \"Iron Bank\";\n  }\n\n  function getUnmapped() public view virtual override returns (address[] memory cTokens) {\n    cTokens = toAddressArray(comptroller.getAllMarkets());\n    uint256 len = cTokens.length;\n    uint256 prevLen = totalMapped;\n    if (len == prevLen) {\n      assembly { mstore(cTokens, 0) }\n    } else {\n      assembly {\n        cTokens := add(cTokens, mul(prevLen, 32))\n        mstore(cTokens, sub(len, prevLen))\n      }\n    }\n  }\n\n  function toAddressArray(ICToken[] memory cTokens) internal pure returns (address[] memory arr) {\n    assembly { arr := cTokens }\n  }\n\n/* ========== Internal Queries ========== */\n\n  function isAdapterMarketFrozen(address adapter) internal view virtual override returns (bool) {\n    return isTokenMarketFrozen(IErc20Adapter(adapter).token());\n  }\n\n  function isTokenMarketFrozen(address cToken) internal view virtual override returns (bool) {\n    if (comptroller.mintGuardianPaused(cToken)) {\n      return true;\n    }\n    return IERC20(cToken).totalSupply() == 0;\n  }\n}"
    },
    "contracts/adapters/ironbank/CyErc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractErc20Adapter.sol\";\nimport \"../../interfaces/CompoundInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { CyTokenParams } from \"../../libraries/CyTokenParams.sol\";\n\n\ncontract CyErc20Adapter is AbstractErc20Adapter() {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"IronBank\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(token);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return (\n      tokenAmount\n      .mul(CyTokenParams.currentExchangeRate(token))\n      / uint256(1e18)\n    );\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount\n      .mul(1e18)\n      / CyTokenParams.currentExchangeRate(token);\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256) {\n    return CyTokenParams.getSupplyRate(token, 0);\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    return CyTokenParams.getSupplyRate(token, liquidityDelta);\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return toUnderlyingAmount(ICToken(token).balanceOf(msg.sender));\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual override {\n    underlying.safeApproveMax(token);\n  }\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    address _token = token;\n    require(ICToken(_token).mint(amountUnderlying) == 0, \"CErc20: Mint failed\");\n    amountMinted = IERC20(_token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(ICToken(token).redeem(amountToken) == 0, \"CErc20: Burn failed\");\n    amountReceived = IERC20(underlying).balanceOf(address(this));\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = toWrappedAmount(amountUnderlying);\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(ICToken(token).redeemUnderlying(amountUnderlying) == 0, \"CrErc20: Burn failed\");\n  }\n}"
    },
    "contracts/adapters/ironbank/CyEtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractEtherAdapter.sol\";\nimport \"../../interfaces/CompoundInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { CyTokenParams } from \"../../libraries/CyTokenParams.sol\";\n\n\ncontract CyEtherAdapter is AbstractEtherAdapter() {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"IronBank\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(token);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return (\n      tokenAmount\n      .mul(CyTokenParams.currentExchangeRate(token))\n      / uint256(1e18)\n    );\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount\n      .mul(1e18)\n      / CyTokenParams.currentExchangeRate(token);\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256) {\n    return CyTokenParams.getSupplyRate(token, 0);\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    return CyTokenParams.getSupplyRate(token, liquidityDelta);\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return toUnderlyingAmount(ICToken(token).balanceOf(msg.sender));\n  }\n\n/* ========== Internal Ether Handlers ========== */\n  \n  // Convert to WETH if contract takes WETH\n  function _afterReceiveETH(uint256 amount) internal virtual override {\n    IWETH(underlying).deposit{value: amount}();\n  }\n\n  // Convert to ETH if contract takes ETH\n  function _afterReceiveWETH(uint256 amount) internal virtual override {}\n\n  // Convert to ETH if contract returns WETH\n  function _beforeSendETH(uint256 amount) internal virtual override {\n    IWETH(underlying).withdraw(amount);\n  }\n\n  // Convert to WETH if contract returns ETH\n  function _beforeSendWETH(uint256 amount) internal virtual override {}\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual override {\n    underlying.safeApproveMax(token);\n  }\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    address _token = token;\n    require(ICToken(_token).mint(amountUnderlying) == 0, \"CErc20: Mint failed\");\n    amountMinted = IERC20(_token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(ICToken(token).redeem(amountToken) == 0, \"CErc20: Burn failed\");\n    amountReceived = IERC20(underlying).balanceOf(address(this));\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = toWrappedAmount(amountUnderlying);\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(ICToken(token).redeemUnderlying(amountUnderlying) == 0, \"CrErc20: Burn failed\");\n  }\n}"
    },
    "contracts/adapters/AbstractErc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/SymbolHelper.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n\nabstract contract AbstractErc20Adapter {\n  using SymbolHelper for address;\n  using TransferHelper for address;\n\n/* ========== Storage ========== */\n\n  address public underlying;\n  address public token;\n\n/* ========== Initializer ========== */\n\n  function initialize(address _underlying, address _token) public virtual {\n    require(underlying == address(0) && token == address(0), \"initialized\");\n    require(_underlying != address(0) && _token != address(0), \"bad address\");\n    underlying = _underlying;\n    token = _token;\n    _approve();\n  }\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual returns (string memory);\n\n/* ========== Metadata ========== */\n\n  function name() external view virtual returns (string memory) {\n    return string(abi.encodePacked(\n      bytes(_protocolName()),\n      \" \",\n      bytes(underlying.getSymbol()),\n      \" Adapter\"\n    ));\n  }\n\n  function availableLiquidity() public view virtual returns (uint256);\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) external view virtual returns (uint256);\n\n  function toWrappedAmount(uint256 underlyingAmount) external view virtual returns (uint256);\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual returns (uint256);\n\n  function getHypotheticalAPR(int256 _deposit) external view virtual returns (uint256);\n\n  function getRevenueBreakdown()\n    external\n    view\n    virtual\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    assets = new address[](1);\n    aprs = new uint256[](1);\n    assets[0] = underlying;\n    aprs[0] = getAPR();\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceWrapped() public view virtual returns (uint256) {\n    return IERC20(token).balanceOf(msg.sender);\n  }\n\n  function balanceUnderlying() external view virtual returns (uint256);\n\n/* ========== Token Actions ========== */\n\n  function deposit(uint256 amountUnderlying) external virtual returns (uint256 amountMinted) {\n    require(amountUnderlying > 0, \"deposit 0\");\n    underlying.safeTransferFrom(msg.sender, address(this), amountUnderlying);\n    amountMinted = _mint(amountUnderlying);\n    token.safeTransfer(msg.sender, amountMinted);\n  }\n\n  function withdraw(uint256 amountToken) public virtual returns (uint256 amountReceived) {\n    require(amountToken > 0, \"withdraw 0\");\n    token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = _burn(amountToken);\n    underlying.safeTransfer(msg.sender, amountReceived);\n  }\n\n  function withdrawAll() public virtual returns (uint256 amountReceived) {\n    return withdraw(balanceWrapped());\n  }\n\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual returns (uint256 amountBurned) {\n    require(amountUnderlying > 0, \"withdraw 0\");\n    amountBurned = _burnUnderlying(amountUnderlying);\n    underlying.safeTransfer(msg.sender, amountUnderlying);\n  }\n\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual returns (uint256 amountReceived) {\n    require(amountUnderlying > 0, \"withdraw 0\");\n    uint256 amountAvailable = availableLiquidity();\n    amountReceived = amountAvailable < amountUnderlying ? amountAvailable : amountUnderlying;\n    _burnUnderlying(amountReceived);\n    underlying.safeTransfer(msg.sender, amountReceived);\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual;\n\n  /**\n   * @dev Deposit `amountUnderlying` into the wrapper and return the amount of wrapped tokens received.\n   * Note:\n   * - Called after the underlying token is transferred.\n   * - Should not transfer minted token to caller.\n   */\n  function _mint(uint256 amountUnderlying) internal virtual returns (uint256 amountMinted);\n\n  /**\n   * @dev Burn `amountToken` of `token` and return the amount of `underlying` received.\n   * Note:\n   * - Called after the wrapper token is transferred.\n   * - Should not transfer underlying token to caller.\n   */\n  function _burn(uint256 amountToken) internal virtual returns (uint256 amountReceived);\n\n  /**\n   * @dev Redeem `amountUnderlying` of the underlying token and return the amount of wrapper tokens burned.\n   * Note:\n   * - Should transfer the wrapper token from the caller.\n   * - Should not transfer underlying token to caller.\n   */\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual returns (uint256 amountBurned);\n}"
    },
    "contracts/libraries/CyTokenParams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../interfaces/CompoundInterfaces.sol\";\nimport \"./LowGasSafeMath.sol\";\nimport \"./MinimalSignedMath.sol\";\n\n\nlibrary CyTokenParams {\n  using LowGasSafeMath for uint256;\n  using MinimalSignedMath for uint256;\n\n  uint256 internal constant EXP_SCALE = 1e18;\n\n  function getInterestRateParameters(address token) internal view returns (\n    address model,\n    uint256 cashPrior,\n    uint256 borrowsPrior,\n    uint256 reservesPrior,\n    uint256 reserveFactorMantissa\n  ) {\n    ICToken cToken = ICToken(token);\n    model = address(cToken.interestRateModel());\n\n    cashPrior = cToken.getCash();\n    borrowsPrior = cToken.totalBorrows();\n    uint256 borrowsPriorForInterestCalculation = borrowsPrior.sub(cToken.borrowBalanceStored(0x560A8E3B79d23b0A525E15C6F3486c6A293DDAd2));\n    reservesPrior = cToken.totalReserves();\n    uint256 accrualBlockNumber = cToken.accrualBlockNumber();\n    uint256 blockDelta = block.number - accrualBlockNumber;\n    reserveFactorMantissa = cToken.reserveFactorMantissa();\n    if (blockDelta > 0) {\n      uint256 borrowRateMantissa = getBorrowRate(address(model), cashPrior, borrowsPriorForInterestCalculation, reservesPrior);\n      uint256 interestAccumulated = mulScalarTruncate(borrowRateMantissa.mul(blockDelta), borrowsPriorForInterestCalculation);\n      borrowsPrior = borrowsPrior.add(interestAccumulated);\n      reservesPrior = mulScalarTruncate(reserveFactorMantissa, interestAccumulated).add(reservesPrior);\n    }\n  }\n\n  function getSupplyRate(address token, int256 liquidityDelta) internal view returns (uint256) {\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = getInterestRateParameters(token);\n    return IInterestRateModel(model).getSupplyRate(\n      cashPrior.add(liquidityDelta),\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa\n    ).mul(2102400);\n  }\n\n  function currentExchangeRate(address token) internal view returns (uint256 exchangeRate) {\n    ICToken cToken = ICToken(token);\n    uint256 blockDelta = block.number - cToken.accrualBlockNumber();\n    if (blockDelta == 0) {\n      return cToken.exchangeRateStored();\n    }\n\n    IInterestRateModel model = cToken.interestRateModel();\n    uint256 cashPrior = cToken.getCash();\n    uint256 borrowsPrior = cToken.totalBorrows();\n    uint256 borrowsPriorForInterestCalculation = borrowsPrior.sub(cToken.borrowBalanceStored(0x560A8E3B79d23b0A525E15C6F3486c6A293DDAd2));\n    uint256 reservesPrior = cToken.totalReserves();\n    uint256 reserveFactorMantissa = cToken.reserveFactorMantissa();\n    if (blockDelta > 0) {\n      uint256 borrowRateMantissa = getBorrowRate(address(model), cashPrior, borrowsPriorForInterestCalculation, reservesPrior);\n      uint256 interestAccumulated = mulScalarTruncate(borrowRateMantissa.mul(blockDelta), borrowsPriorForInterestCalculation);\n      borrowsPrior = borrowsPrior.add(interestAccumulated);\n      reservesPrior = mulScalarTruncate(reserveFactorMantissa, interestAccumulated).add(reservesPrior);\n    }\n\n    return cashPrior.add(borrowsPrior).sub(reservesPrior).mul(1e18) / ICToken(token).totalSupply();\n  }\n\n  function truncate(uint256 x) internal pure returns (uint256) {\n    return x / EXP_SCALE;\n  }\n\n  function mulScalarTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n    return truncate(x.mul(y));\n  }\n\n  function mulScalarTruncateAddUInt(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\n    return mulScalarTruncate(x, y).add(z);\n  }\n\n  function getBorrowRate(\n    address model,\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) internal view returns (uint256 borrowRateMantissa) {\n    (bool success, bytes memory retData) = model.staticcall(\n      abi.encodeWithSelector(\n        IInterestRateModel.getBorrowRate.selector,\n        cash,\n        borrows,\n        reserves\n      )\n    );\n    if (!success) revert(abi.decode(retData, (string)));\n    assembly {\n      switch lt(mload(retData), 64)\n      case 0 {borrowRateMantissa := mload(add(retData, 64))}\n      default {borrowRateMantissa := mload(add(retData, 32))}\n    }\n  }\n}"
    },
    "contracts/adapters/AbstractEtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../libraries/TransferHelper.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"./AbstractErc20Adapter.sol\";\n\n\nabstract contract AbstractEtherAdapter is AbstractErc20Adapter {\n  using TransferHelper for address;\n\n/* ========== Metadata ========== */\n\n  function name() external view virtual override returns (string memory) {\n    return string(abi.encodePacked(\n      bytes(_protocolName()),\n      \" ETH Adapter\"\n    ));\n  }\n\n/* ========== Fallback ========== */\n\n  fallback() external payable { return; }\n\n  receive() external payable { return; }\n\n/* ========== Token Actions ========== */\n\n  function deposit(uint256 amountUnderlying)\n    external\n    virtual\n    override\n    returns (uint256 amountMinted)\n  {\n    underlying.safeTransferFrom(msg.sender, address(this), amountUnderlying);\n    _afterReceiveWETH(amountUnderlying);\n    amountMinted = _mint(amountUnderlying);\n    token.safeTransfer(msg.sender, amountMinted);\n  }\n\n  function depositETH() external virtual payable returns (uint256 amountMinted) {\n    _afterReceiveETH(msg.value);\n    amountMinted = _mint(msg.value);\n    token.safeTransfer(msg.sender, amountMinted);\n  }\n\n  function withdraw(uint256 amountToken) public virtual override returns (uint256 amountReceived) {\n    token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = _burn(amountToken);\n    _beforeSendWETH(amountReceived);\n    underlying.safeTransfer(msg.sender, amountReceived);\n  }\n\n  function withdrawAsETH(uint256 amountToken) public virtual returns (uint256 amountReceived) {\n    token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = _burn(amountToken);\n    _beforeSendETH(amountReceived);\n    address(msg.sender).safeTransferETH(amountReceived);\n  }\n\n  function withdrawAllAsETH() public virtual returns (uint256 amountReceived) {\n    return withdrawAsETH(balanceWrapped());\n  }\n\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\n    amountBurned = _burnUnderlying(amountUnderlying);\n    _beforeSendWETH(amountUnderlying);\n    underlying.safeTransfer(msg.sender, amountUnderlying);\n  }\n\n  function withdrawUnderlyingAsETH(uint256 amountUnderlying) external virtual returns (uint256 amountBurned) {\n    amountBurned = _burnUnderlying(amountUnderlying);\n    _beforeSendETH(amountUnderlying);\n    address(msg.sender).safeTransferETH(amountUnderlying);\n  }\n\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual override returns (uint256 amountReceived) {\n    require(amountUnderlying > 0, \"withdraw 0\");\n    uint256 amountAvailable = availableLiquidity();\n    amountReceived = amountAvailable < amountUnderlying ? amountAvailable : amountUnderlying;\n    _burnUnderlying(amountReceived);\n    _beforeSendWETH(amountReceived);\n    underlying.safeTransfer(msg.sender, amountReceived);\n  }\n\n/* ========== Internal Ether Handlers ========== */\n  \n  // Convert to WETH if contract takes WETH\n  function _afterReceiveETH(uint256 amount) internal virtual;\n\n  // Convert to WETH if contract takes ETH\n  function _afterReceiveWETH(uint256 amount) internal virtual;\n\n  // Convert to ETH if contract returns WETH\n  function _beforeSendETH(uint256 amount) internal virtual;\n\n  // Convert to WETH if contract returns ETH\n  function _beforeSendWETH(uint256 amount) internal virtual;\n}"
    },
    "contracts/test/TestAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"./TestERC20.sol\";\nimport \"./TestVault.sol\";\nimport \"../libraries/MinimalSignedMath.sol\";\n\ncontract TestAdapter {\n  using LowGasSafeMath for uint256;\n  using MinimalSignedMath for uint256;\n  using TransferHelper for address;\n\n  address public immutable underlying;\n  address public immutable token;\n  uint256 public annualInterest;\n  bool internal restrictedLiquidity;\n  uint256 internal _availableLiquidity;\n  bool internal revertOnAPRQQuery;\n  address[] internal revenueTokens;\n  uint256[] internal revenueAPRs;\n\n  constructor(address _underlying, address _token, uint256 _annualInterest) {\n    underlying = _underlying;\n    token = _token;\n    annualInterest = _annualInterest;\n    _underlying.safeApproveMax(_token);\n  }\n\n  function setRevenueBreakdown(\n    address[] memory _revenueTokens,\n    uint256[] memory _revenueAPRs\n  ) external {\n    revenueTokens = _revenueTokens;\n    revenueAPRs = _revenueAPRs;\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    returns (\n      address[] memory _revenueTokens,\n      uint256[] memory _revenueAPRs\n    )\n  {\n    _revenueTokens = revenueTokens;\n    _revenueAPRs = revenueAPRs;\n  }\n\n  function availableLiquidity() public view returns (uint256) {\n    if (restrictedLiquidity) return _availableLiquidity;\n    return IERC20(underlying).balanceOf(token);\n  }\n\n  function setAvailableLiquidity(uint256 amount) external {\n    restrictedLiquidity = true;\n    _availableLiquidity = amount;\n  }\n  function setRevertOnAPRQQuery(bool _revertOnAPRQQuery) external {\n    revertOnAPRQQuery = _revertOnAPRQQuery;\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view returns (uint256) {\n    TestVault vault = TestVault(token);\n    uint256 bal = vault.balance();\n    uint256 supply = vault.totalSupply();\n    return supply == 0 ? underlyingAmount : (underlyingAmount.mul(supply) / bal);\n  }\n\n  function toUnderlyingAmount(uint256 wrappedAmount) public view returns (uint256) {\n    TestVault vault = TestVault(token);\n    return vault.balance().mul(wrappedAmount) / vault.totalSupply();\n  }\n\n  function setAnnualInterest(uint256 _annualInterest) external {\n    annualInterest = _annualInterest;\n  }\n\n  function getAPR() external view returns (uint256) {\n    if (revertOnAPRQQuery) revert();\n    return annualInterest.mul(1e18) / TestVault(token).balance();\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view returns (uint256) {\n    if (revertOnAPRQQuery) revert();\n    return annualInterest.mul(1e18) / TestVault(token).balance().add(liquidityDelta);\n  }\n\n  function balanceWrapped() public view returns (uint256) {\n    return IERC20(token).balanceOf(msg.sender);\n  }\n\n  function balanceUnderlying() external view returns (uint256) {\n    return toUnderlyingAmount(balanceWrapped());\n  }\n\n  function mintTo(address to, uint256 amount) external {\n    TestERC20(underlying).mint(address(this), amount);\n    uint256 amountMinted = TestVault(token).deposit(amount);\n    token.safeTransfer(to, amountMinted);\n  }\n\n  function deposit(uint256 amountUnderlying) external virtual returns (uint256 amountMinted) {\n    require(amountUnderlying > 0, \"deposit 0\");\n    underlying.safeTransferFrom(msg.sender, address(this), amountUnderlying);\n    amountMinted = TestVault(token).deposit(amountUnderlying);\n    token.safeTransfer(msg.sender, amountMinted);\n  }\n\n  function withdraw(uint256 amountToken) public virtual returns (uint256 amountReceived) {\n    require(amountToken > 0, \"withdraw 0\");\n    token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = TestVault(token).withdraw(amountToken);\n    underlying.safeTransfer(msg.sender, amountReceived);\n  }\n\n  function withdrawAll() public virtual returns (uint256 amountReceived) {\n    return withdraw(balanceWrapped());\n  }\n\n  function withdrawUnderlying(uint256 amountUnderlying) public returns (uint256 amountBurned) {\n    TestVault vault = TestVault(token);\n    uint256 bal = vault.balance();\n    uint256 supply = vault.totalSupply();\n    amountBurned = amountUnderlying.mul(supply).divCeil(bal);\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    TestVault(token).withdraw(amountBurned);\n    underlying.safeTransfer(msg.sender, amountUnderlying);\n  }\n\n  function withdrawUnderlyingUpTo(uint256 amountToWithdraw) external returns (uint256 amountReceived) {\n    uint256 available = availableLiquidity();\n    amountReceived = amountToWithdraw > available ? available : amountToWithdraw;\n    if (amountReceived == 0) return 0;\n    withdrawUnderlying(amountReceived);\n  }\n}"
    },
    "contracts/test/TestERC20.sol": {
      "content": "pragma solidity =0.7.6;\n\nimport \"../vaults/ERC20.sol\";\n\ncontract TestERC20 is ERC20 {\n  string public name;\n  string public symbol;\n\n  constructor(string memory _name, string memory _symbol, uint256 initBalance) {\n    name = _name;\n    symbol = _symbol;\n    if (initBalance > 0) _mint(msg.sender, initBalance);\n  }\n\n  function mint(address to, uint256 amount) external {\n    _mint(to, amount);\n  }\n}"
    },
    "contracts/test/TestAdapterHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"../libraries/AdapterHelper.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\ncontract TestAdapterHelper {\n  using TransferHelper for address;\n  using AdapterHelper for IErc20Adapter;\n  using AdapterHelper for IErc20Adapter[];\n  using AdapterHelper for uint256;\n  using AdapterHelper for bytes32;\n  using AdapterHelper for bytes32[];\n\n  function approve(IErc20Adapter adapter) external {\n    adapter.underlying().safeApproveMax(address(adapter));\n    address(adapter.token()).safeApproveMax(address(adapter));\n  }\n\n  function testDeposit(IErc20Adapter adapter, uint256 amount) external {\n    adapter.underlying().safeApproveMax(address(adapter));\n    adapter.deposit(amount);\n    address(adapter.token()).safeApproveMax(address(adapter));\n  }\n\n  function packAdapterAndWeight(\n    IErc20Adapter adapter,\n    uint256 weight\n  )\n    external\n    pure\n    returns (bytes32 encoded)\n  {\n    return adapter.packAdapterAndWeight(weight);\n  }\n\n  function packAdaptersAndWeights(\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights\n  )\n    external\n    pure\n    returns (bytes32[] memory encodedArray)\n  {\n    return adapters.packAdaptersAndWeights(weights);\n  }\n\n  function unpackAdapterAndWeight(bytes32 encoded)\n    external\n    pure\n    returns (\n      IErc20Adapter adapter,\n      uint256 weight\n    )\n  {\n    return encoded.unpackAdapterAndWeight();\n  }\n\n  function unpackAdaptersAndWeights(bytes32[] memory encodedArray)\n    external\n    pure\n    returns (\n      IErc20Adapter[] memory adapters,\n      uint256[] memory weights\n    )\n  {\n    return encodedArray.unpackAdaptersAndWeights();\n  }\n\n  function getNetAPR(\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights,\n    int256[] memory liquidityDeltas\n  ) external view returns (uint256 netAPR)\n  {\n    return adapters.getNetAPR(weights, liquidityDeltas);\n  }\n\n  function getLiquidityDeltas(\n    uint256 totalProductiveBalance,\n    uint256[] memory balances,\n    uint256[] memory weights\n  ) external pure returns (int256[] memory deltas)\n  {\n    return totalProductiveBalance.getLiquidityDeltas(balances, weights);\n  }\n\n  function getBalances(IErc20Adapter[] memory adapters)\n    external\n    view\n    returns (uint256[] memory balances)\n  {\n    return adapters.getBalances();\n  }\n\n  function getExcludedAdapterIndices(\n    IErc20Adapter[] memory oldAdapters,\n    IErc20Adapter[] memory newAdapters\n  ) external pure returns (uint256[] memory excludedAdapterIndices)\n  {\n    return oldAdapters.getExcludedAdapterIndices(newAdapters);\n  }\n\n  function rebalance(\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights,\n    int256[] memory liquidityDeltas,\n    uint256 reserveBalance\n  ) external returns (uint256[] memory removedIndices)\n  {\n    return adapters.rebalance(weights, liquidityDeltas, reserveBalance);\n  }\n}"
    },
    "contracts/adapters/fuse/FuseEtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractEtherAdapter.sol\";\nimport \"../../interfaces/FuseInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { CTokenParams } from \"../../libraries/CTokenParams.sol\";\n\n\ncontract FuseEtherAdapter is AbstractEtherAdapter() {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Storage ========== */\n\n  string internal __protocolName;\n\n/* ========== Initializer ========== */\n\n  function initialize(\n    address _underlying,\n    address _token,\n    string memory protocolName\n  ) public {\n    super.initialize(_underlying, _token);\n    __protocolName = protocolName;\n  }\n\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return __protocolName;\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return address(token).balance;\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) external view virtual override returns (uint256) {\n    return tokenAmount;\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) external view virtual override returns (uint256) {\n    return underlyingAmount;\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256) {\n    return IFToken(token).supplyRatePerBlock().mul(2102400);\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    IFToken fToken = IFToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = CTokenParams.getInterestRateParameters(address(fToken));\n    return IInterestRateModel(model).getSupplyRate(\n      cashPrior.add(liquidityDelta),\n      borrowsPrior,\n      reservesPrior.add(fToken.totalFuseFees()).add(fToken.totalAdminFees()),\n      reserveFactorMantissa.add(fToken.fuseFeeMantissa()).add(fToken.adminFeeMantissa())\n    ).mul(2102400);\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return IFToken(token).balanceOf(msg.sender).mul(IFToken(token).exchangeRateStored()) / 1e18;\n  }\n\n/* ========== Internal Ether Handlers ========== */\n  \n  // Convert to WETH if contract takes WETH\n  function _afterReceiveETH(uint256 amount) internal virtual override {}\n\n  // Convert to WETH if contract takes ETH\n  function _afterReceiveWETH(uint256 amount) internal virtual override {\n    IWETH(underlying).withdraw(amount);\n  }\n\n  // Convert to ETH if contract returns WETH\n  function _beforeSendETH(uint256 amount) internal virtual override {}\n\n  // Convert to WETH if contract returns ETH\n  function _beforeSendWETH(uint256 amount) internal virtual override {\n    IWETH(underlying).deposit{value: amount}();\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual override {}\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    require(IFToken(token).mint{value: amountUnderlying}() == 0, \"CEther: Mint failed\");\n    amountMinted = IERC20(token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(IFToken(token).redeem(amountToken) == 0, \"CEther: Burn failed\");\n    amountReceived = IERC20(underlying).balanceOf(address(this));\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = amountUnderlying.mul(1e18).divCeil(IFToken(token).exchangeRateCurrent());\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(IFToken(token).redeemUnderlying(amountUnderlying) == 0, \"CEther: Burn failed\");\n  }\n}"
    },
    "contracts/libraries/CTokenParams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../interfaces/CompoundInterfaces.sol\";\nimport \"./LowGasSafeMath.sol\";\nimport \"./MinimalSignedMath.sol\";\n\n\nlibrary CTokenParams {\n  using LowGasSafeMath for uint256;\n  using MinimalSignedMath for uint256;\n\n  uint256 internal constant EXP_SCALE = 1e18;\n  uint256 internal constant HALF_EXP_SCALE = 5e17;\n\n  function getInterestRateParameters(address token) internal view returns (\n    address model,\n    uint256 cashPrior,\n    uint256 borrowsPrior,\n    uint256 reservesPrior,\n    uint256 reserveFactorMantissa\n  ) {\n    ICToken cToken = ICToken(token);\n    model = address(cToken.interestRateModel());\n\n    cashPrior = cToken.getCash();\n    borrowsPrior = cToken.totalBorrows();\n    reservesPrior = cToken.totalReserves();\n    uint256 accrualBlockNumber = cToken.accrualBlockNumber();\n    uint256 blockDelta = block.number - accrualBlockNumber;\n    reserveFactorMantissa = cToken.reserveFactorMantissa();\n    if (blockDelta > 0) {\n      uint256 borrowRateMantissa = getBorrowRate(address(model), cashPrior, borrowsPrior, reservesPrior);\n      uint256 interestAccumulated = mulScalarTruncate(borrowRateMantissa.mul(blockDelta), borrowsPrior);\n      borrowsPrior = borrowsPrior.add(interestAccumulated);\n      reservesPrior = mulScalarTruncate(reserveFactorMantissa, interestAccumulated).add(reservesPrior);\n    }\n  }\n\n  function currentExchangeRate(address token) internal view returns (uint256 exchangeRate) {\n    ICToken cToken = ICToken(token);\n    uint256 blockDelta = block.number - cToken.accrualBlockNumber();\n    if (blockDelta == 0) {\n      return cToken.exchangeRateStored();\n    }\n\n    IInterestRateModel model = cToken.interestRateModel();\n\n    uint256 cashPrior = cToken.getCash();\n    uint256 borrowsPrior = cToken.totalBorrows();\n    uint256 reservesPrior = cToken.totalReserves();\n    uint256 reserveFactorMantissa = cToken.reserveFactorMantissa();\n    if (blockDelta > 0) {\n      uint256 borrowRateMantissa = getBorrowRate(address(model), cashPrior, borrowsPrior, reservesPrior);\n      uint256 interestAccumulated = mulScalarTruncate(borrowRateMantissa.mul(blockDelta), borrowsPrior);\n      borrowsPrior = borrowsPrior.add(interestAccumulated);\n      reservesPrior = mulScalarTruncate(reserveFactorMantissa, interestAccumulated).add(reservesPrior);\n    }\n\n    return cashPrior.add(borrowsPrior).sub(reservesPrior).mul(1e18) / ICToken(token).totalSupply();\n  }\n  \n\n  function truncate(uint256 x) internal pure returns (uint256) {\n    return x / EXP_SCALE;\n  }\n\n  function mulScalarTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n    return truncate(x.mul(y));\n  }\n\n  function mulScalarTruncateAddUInt(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\n    return mulScalarTruncate(x, y).add(z);\n  }\n\n  function getBorrowRate(\n    address model,\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) internal view returns (uint256 borrowRateMantissa) {\n    (bool success, bytes memory retData) = model.staticcall(\n      abi.encodeWithSelector(\n        IInterestRateModel.getBorrowRate.selector,\n        cash,\n        borrows,\n        reserves\n      )\n    );\n    if (!success) revert(abi.decode(retData, (string)));\n    assembly {\n      switch lt(mload(retData), 64)\n      case 0 {borrowRateMantissa := mload(add(retData, 64))}\n      default {borrowRateMantissa := mload(add(retData, 32))}\n    }\n  }\n}"
    },
    "contracts/protocols/FusePoolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/FuseInterfaces.sol\";\nimport \"../adapters/fuse/FuseErc20Adapter.sol\";\nimport \"../adapters/fuse/FuseEtherAdapter.sol\";\nimport \"./AbstractProtocolAdapter.sol\";\n\n\ncontract FuseProtocolAdapter is AbstractProtocolAdapter {\n  using CloneLibrary for address;\n\n/* ========== Constants ========== */\n\n  address public immutable fuseProtocolAdapter;\n  address public immutable erc20AdapterImplementation;\n  address public immutable etherAdapterImplementation;\n\n/* ========== Storage ========== */\n\n  IFusePool public pool;\n  string internal _fusePoolName;\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) AbstractProtocolAdapter(_registry) {\n    erc20AdapterImplementation = address(new FuseErc20Adapter());\n    etherAdapterImplementation = address(new FuseEtherAdapter());\n    fuseProtocolAdapter = msg.sender;\n  }\n\n  function initialize(IFusePool _pool, string memory fusePoolName) external {\n    require(msg.sender == fuseProtocolAdapter, \"!fuse adapter\");\n    require(address(pool) == address(0), \"already initialized\");\n    pool = _pool;\n    _fusePoolName = fusePoolName;\n  }\n\n/* ========== Internal Actions ========== */\n\n  function deployAdapter(address fToken) internal virtual override returns (address adapter) {\n    address underlying;\n    // The call to underlying will use all the gas sent if it fails,\n    // so we specify a maximum of 25k gas. The contract will only use ~2k\n    // but this protects against all likely changes to the gas schedule.\n    try IFToken(fToken).underlying{gas: 25000}() returns (address _underlying) {\n      underlying = _underlying;\n      if (underlying == address(0)) {\n        underlying = weth;\n      }\n    } catch {\n      underlying = weth;\n    }\n    if (underlying == weth) {\n      adapter = CloneLibrary.createClone(etherAdapterImplementation);\n    } else {\n      adapter = CloneLibrary.createClone(erc20AdapterImplementation);\n    }\n    FuseErc20Adapter(adapter).initialize(underlying, fToken, _fusePoolName);\n  }\n\n/* ========== Public Queries ========== */\n\n  function protocol() external view virtual override returns (string memory) {\n    return _fusePoolName;\n  }\n\n  function getUnmapped() public view virtual override returns (address[] memory fTokens) {\n    fTokens = toAddressArray(pool.getAllMarkets());\n    uint256 len = fTokens.length;\n    uint256 prevLen = totalMapped;\n    if (len == prevLen) {\n      assembly { mstore(fTokens, 0) }\n    } else {\n      assembly {\n        fTokens := add(fTokens, mul(prevLen, 32))\n        mstore(fTokens, sub(len, prevLen))\n      }\n    }\n  }\n\n  function toAddressArray(IFToken[] memory fTokens) internal pure returns (address[] memory arr) {\n    assembly { arr := fTokens }\n  }\n\n/* ========== Internal Queries ========== */\n\n  function isAdapterMarketFrozen(address adapter) internal view virtual override returns (bool) {\n    return isTokenMarketFrozen(IErc20Adapter(adapter).token());\n  }\n\n  function isTokenMarketFrozen(address fToken) internal view virtual override returns (bool) {\n    return pool.mintGuardianPaused(fToken);\n  }\n}"
    },
    "contracts/adapters/fuse/FuseErc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractErc20Adapter.sol\";\nimport \"../../interfaces/FuseInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { CTokenParams } from \"../../libraries/CTokenParams.sol\";\n\n\ncontract FuseErc20Adapter is AbstractErc20Adapter {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Storage ========== */\n\n  string internal __protocolName;\n\n/* ========== Initializer ========== */\n\n  function initialize(\n    address _underlying,\n    address _token,\n    string memory protocolName\n  ) public {\n    super.initialize(_underlying, _token);\n    __protocolName = protocolName;\n  }\n\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return __protocolName;\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(token);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return (\n      tokenAmount\n      .mul(CTokenParams.currentExchangeRate(token))\n      / uint256(1e18)\n    );\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount\n      .mul(1e18)\n      / CTokenParams.currentExchangeRate(token);\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256) {\n    return IFToken(token).supplyRatePerBlock().mul(2102400);\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    IFToken fToken = IFToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = CTokenParams.getInterestRateParameters(address(fToken));\n    return IInterestRateModel(model).getSupplyRate(\n      cashPrior.add(liquidityDelta),\n      borrowsPrior,\n      reservesPrior.add(fToken.totalFuseFees()).add(fToken.totalAdminFees()),\n      reserveFactorMantissa.add(fToken.fuseFeeMantissa()).add(fToken.adminFeeMantissa())\n    ).mul(2102400);\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return IFToken(token).balanceOf(msg.sender).mul(IFToken(token).exchangeRateStored()) / 1e18;\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual override {\n    underlying.safeApproveMax(token);\n  }\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    require(IFToken(token).mint(amountUnderlying) == 0, \"CErc20: Mint failed\");\n    amountMinted = IERC20(token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(IFToken(token).redeem(amountToken) == 0, \"CErc20: Burn failed\");\n    amountReceived = IERC20(underlying).balanceOf(address(this));\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = amountUnderlying.mul(1e18).divCeil(IFToken(token).exchangeRateCurrent());\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(IFToken(token).redeemUnderlying(amountUnderlying) == 0, \"CErc20: Burn failed\");\n  }\n}"
    },
    "contracts/test/IdleFuse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { CTokenParams } from \"../libraries/CTokenParams.sol\";\n\ninterface FuseCERC20 {\n  function totalReserves() external view returns (uint256);\n  function getCash() external view returns (uint256);\n  function totalBorrows() external view returns (uint256);\n  function reserveFactorMantissa() external view returns (uint256);\n  function interestRateModel() external view returns (address);\n  function underlying() external view returns (address);\n  function totalFuseFees() external view returns(uint256);\n  function totalAdminFees() external view returns(uint256);\n  function fuseFeeMantissa() external view returns(uint256);\n  function adminFeeMantissa() external view returns(uint256);\n  function accrueInterest() external;\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function exchangeRateCurrent() external returns (uint256);\n  function exchangeRateStored() external view returns (uint256);\n  function accrualBlockNumber() external view returns (uint256);\n}\n\ninterface WhitePaperInterestRateModel {\n  function getBorrowRate(uint256 cash, uint256 borrows, uint256 _reserves) external view returns (uint256);\n  function getSupplyRate(uint256 cash, uint256 borrows, uint256 reserves, uint256 reserveFactorMantissa) external view returns (uint256);\n  function multiplier() external view returns (uint256);\n  function baseRate() external view returns (uint256);\n  function blocksPerYear() external view returns (uint256);\n  function dsrPerBlock() external view returns (uint256);\n}\n\n// 0xe2451Ae4579AeDAa933148481732498533db185e\n\ncontract IdleFuse {\n  using SafeMath for uint256;\n  function nextSupplyRate(uint256 _amount)\n    external view\n    returns (uint256) {\n      address token = 0x558a7A68C574D83f327E7008c63A86613Ea48B4f;\n      FuseCERC20 cToken = FuseCERC20(token);\n      WhitePaperInterestRateModel white = WhitePaperInterestRateModel(FuseCERC20(token).interestRateModel());\n      uint256 ratePerBlock = white.getSupplyRate(\n        cToken.getCash().add(_amount),\n        cToken.totalBorrows(),\n        cToken.totalReserves().add(cToken.totalFuseFees()).add(cToken.totalAdminFees()),\n        cToken.reserveFactorMantissa().add(cToken.fuseFeeMantissa()).add(cToken.adminFeeMantissa())\n      );\n      return ratePerBlock.mul(2102400);\n  }\n\n  function nextSupplyRate2(uint256 _amount) external view returns (uint256) {\n      address token = 0x558a7A68C574D83f327E7008c63A86613Ea48B4f;\n      FuseCERC20 cToken = FuseCERC20(token);\n      WhitePaperInterestRateModel white = WhitePaperInterestRateModel(FuseCERC20(token).interestRateModel());\n      uint256 ratePerBlock = white.getSupplyRate(\n        cToken.getCash().add(_amount),\n        cToken.totalBorrows(),\n        cToken.totalReserves(),\n        cToken.reserveFactorMantissa()\n      );\n      return ratePerBlock.mul(2102400);\n  }\n\n  function nextSupplyRate3(uint256 _amount) external view returns (uint256) {\n      address token = 0x558a7A68C574D83f327E7008c63A86613Ea48B4f;\n      (\n        address model,\n        uint256 cashPrior,\n        uint256 borrowsPrior,\n        uint256 reservesPrior,\n        uint256 reserveFactorMantissa\n      ) = CTokenParams.getInterestRateParameters(token);\n      FuseCERC20 cToken = FuseCERC20(token);\n      WhitePaperInterestRateModel white = WhitePaperInterestRateModel(model);\n      uint256 ratePerBlock = white.getSupplyRate(\n        cashPrior.add(_amount),\n        borrowsPrior,\n        reservesPrior.add(cToken.totalFuseFees()).add(cToken.totalAdminFees()),\n        reserveFactorMantissa.add(cToken.fuseFeeMantissa()).add(cToken.adminFeeMantissa())\n      );\n      return ratePerBlock.mul(2102400);\n  }\n\n  function creamSupplyRate1(uint256 liquidityDelta) external view returns (uint256) {\n    address token = 0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f;\n    WhitePaperInterestRateModel model = WhitePaperInterestRateModel(FuseCERC20(token).interestRateModel());\n    return model.getSupplyRate(\n      FuseCERC20(token).getCash().add(liquidityDelta),\n      FuseCERC20(token).totalBorrows(),\n      FuseCERC20(token).totalReserves(),\n      FuseCERC20(token).reserveFactorMantissa()\n    ).mul(2102400);\n  }\n\n  function creamSupplyRate(uint256 _amount) external view returns (uint256) {\n    // 47663510400\n    // 1110067200\n    address token = 0x92B767185fB3B04F881e3aC8e5B0662a027A1D9f;\n    WhitePaperInterestRateModel model = WhitePaperInterestRateModel(FuseCERC20(token).interestRateModel());\n    uint256 cashPrior = FuseCERC20(token).getCash();\n    uint256 borrowsPrior = FuseCERC20(token).totalBorrows();\n    uint256 reservesPrior = FuseCERC20(token).totalReserves();\n    uint256 accrualBlockNumber = FuseCERC20(token).accrualBlockNumber();\n    uint256 blockDelta = block.number - accrualBlockNumber;\n    uint256 reserveFactorMantissa = FuseCERC20(token).reserveFactorMantissa();\n    if (blockDelta > 0) {\n      uint256 borrowRateMantissa = model.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n      uint256 interestAccumulated = borrowRateMantissa.mul(blockDelta).mul(borrowsPrior) / 1e18;\n      borrowsPrior = borrowsPrior.add(interestAccumulated);\n      reservesPrior = reservesPrior.add(reserveFactorMantissa.mul(interestAccumulated) / 1e18);\n    }\n\n    return model.getSupplyRate(\n      cashPrior.add(_amount),\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa\n    ).mul(2102400);\n    //   FuseCERC20 cToken = FuseCERC20(token);\n    //   WhitePaperInterestRateModel white = WhitePaperInterestRateModel(FuseCERC20(token).interestRateModel());\n    //   uint256 ratePerBlock = white.getSupplyRate(\n    //     cToken.getCash().add(_amount),\n    //     cToken.totalBorrows(),\n    //     cToken.totalReserves(),\n    //     cToken.reserveFactorMantissa()\n    //   );\n    //   return ratePerBlock.mul(2102400);\n  }\n}"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/adapters/cream/CrEtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractEtherAdapter.sol\";\nimport \"../../interfaces/CompoundInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { CTokenParams } from \"../../libraries/CTokenParams.sol\";\n\n\ncontract CrEtherAdapter is AbstractEtherAdapter() {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"Cream\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return address(token).balance;\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return (\n      tokenAmount\n      .mul(CTokenParams.currentExchangeRate(token))\n      / uint256(1e18)\n    );\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount\n      .mul(1e18)\n      / CTokenParams.currentExchangeRate(token);\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256) {\n    return ICToken(token).supplyRatePerBlock().mul(2102400);\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = CTokenParams.getInterestRateParameters(address(cToken));\n    return IInterestRateModel(model).getSupplyRate(\n      cashPrior.add(liquidityDelta),\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa\n    ).mul(2102400);\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return toUnderlyingAmount(ICToken(token).balanceOf(msg.sender));\n  }\n\n/* ========== Internal Ether Handlers ========== */\n  \n  // Convert to WETH if contract takes WETH\n  function _afterReceiveETH(uint256 amount) internal virtual override {}\n\n  // Convert to WETH if contract takes ETH\n  function _afterReceiveWETH(uint256 amount) internal virtual override {\n    IWETH(underlying).withdraw(amount);\n  }\n\n  // Convert to ETH if contract returns WETH\n  function _beforeSendETH(uint256 amount) internal virtual override {}\n\n  // Convert to WETH if contract returns ETH\n  function _beforeSendWETH(uint256 amount) internal virtual override {\n    IWETH(underlying).deposit{value: amount}();\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual override {}\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    address _token = token;\n    ICToken(_token).mint{value: amountUnderlying}();\n    amountMinted = IERC20(_token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(ICToken(token).redeem(amountToken) == 0, \"CEther: Burn failed\");\n    amountReceived = address(this).balance;\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = toWrappedAmount(amountUnderlying);\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(ICToken(token).redeemUnderlying(amountUnderlying) == 0, \"CEther: Burn failed\");\n  }\n}"
    },
    "contracts/protocols/CreamProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/CompoundInterfaces.sol\";\nimport \"../adapters/cream/CrErc20Adapter.sol\";\nimport \"../adapters/cream/CrEtherAdapter.sol\";\nimport \"./AbstractProtocolAdapter.sol\";\n\n\ncontract CreamProtocolAdapter is AbstractProtocolAdapter {\n  using CloneLibrary for address;\n\n/* ========== Constants ========== */\n\n  IComptroller public constant comptroller = IComptroller(0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258);\n  address public immutable erc20AdapterImplementation;\n  address public immutable etherAdapterImplementation;\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) AbstractProtocolAdapter(_registry) {\n    erc20AdapterImplementation = address(new CrErc20Adapter());\n    etherAdapterImplementation = address(new CrEtherAdapter());\n  }\n\n/* ========== Internal Actions ========== */\n\n  function deployAdapter(address cToken) internal virtual override returns (address adapter) {\n    address underlying;\n    // The call to underlying will use all the gas sent if it fails,\n    // so we specify a maximum of 25k gas. The contract will only use ~2k\n    // but this protects against all likely changes to the gas schedule.\n    try ICToken(cToken).underlying{gas: 25000}() returns (address _underlying) {\n      underlying = _underlying;\n      if (underlying == address(0)) {\n        underlying = weth;\n      }\n    } catch {\n      underlying = weth;\n    }\n    if (underlying == weth) {\n      adapter = CloneLibrary.createClone(etherAdapterImplementation);\n    } else {\n      adapter = CloneLibrary.createClone(erc20AdapterImplementation);\n    }\n    CrErc20Adapter(adapter).initialize(underlying, address(cToken));\n  }\n\n/* ========== Public Queries ========== */\n\n  function protocol() external pure virtual override returns (string memory) {\n    return \"Cream\";\n  }\n\n  function getUnmapped() public view virtual override returns (address[] memory cTokens) {\n    cTokens = toAddressArray(comptroller.getAllMarkets());\n    uint256 len = cTokens.length;\n    uint256 prevLen = totalMapped;\n    if (len == prevLen) {\n      assembly { mstore(cTokens, 0) }\n    } else {\n      assembly {\n        cTokens := add(cTokens, mul(prevLen, 32))\n        mstore(cTokens, sub(len, prevLen))\n      }\n    }\n  }\n\n  function toAddressArray(ICToken[] memory cTokens) internal pure returns (address[] memory arr) {\n    assembly { arr := cTokens }\n  }\n\n/* ========== Internal Queries ========== */\n\n  function isAdapterMarketFrozen(address adapter) internal view virtual override returns (bool) {\n    return comptroller.mintGuardianPaused(IErc20Adapter(adapter).token());\n  }\n\n  function isTokenMarketFrozen(address cToken) internal view virtual override returns (bool) {\n    // Return true if market is paused in comptroller\n    bool isFrozen = comptroller.mintGuardianPaused(cToken);\n    if (isFrozen) return true;\n    // Return true if market is for an SLP token, which the adapter can not handle.\n    // The call to `sushi()` will use all the gas sent if it fails, so we specify a\n    // maximum of 25k gas to ensure it will not use all the gas in the transaction, but\n    // can still be executed with any foreseeable changes to the gas schedule.\n    try ICToken(cToken).sushi{gas:25000}() returns (address) {\n      return true;\n    } catch {\n      // Return true is supply is 0.\n      return IERC20(cToken).totalSupply() == 0;\n    }\n  }\n}"
    },
    "contracts/adapters/cream/CrErc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractErc20Adapter.sol\";\nimport \"../../interfaces/CompoundInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { CTokenParams } from \"../../libraries/CTokenParams.sol\";\n\n\ncontract CrErc20Adapter is AbstractErc20Adapter() {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"Cream\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(token);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return (\n      tokenAmount\n      .mul(CTokenParams.currentExchangeRate(token))\n      / uint256(1e18)\n    );\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount\n      .mul(1e18)\n      / CTokenParams.currentExchangeRate(token);\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256) {\n    return ICToken(token).supplyRatePerBlock().mul(2102400);\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = CTokenParams.getInterestRateParameters(address(cToken));\n    return IInterestRateModel(model).getSupplyRate(\n      cashPrior.add(liquidityDelta),\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa\n    ).mul(2102400);\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return toUnderlyingAmount(ICToken(token).balanceOf(msg.sender));\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual override {\n    underlying.safeApproveMax(token);\n  }\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    address _token = token;\n    require(ICToken(_token).mint(amountUnderlying) == 0, \"CrErc20: Mint failed\");\n    amountMinted = IERC20(_token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(ICToken(token).redeem(amountToken) == 0, \"CrErc20: Burn failed\");\n    amountReceived = IERC20(underlying).balanceOf(address(this));\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = toWrappedAmount(amountUnderlying);\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(ICToken(token).redeemUnderlying(amountUnderlying) == 0, \"CrErc20: Burn failed\");\n  }\n}"
    },
    "contracts/libraries/RebalanceValidation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"../interfaces/IAdapterRegistry.sol\";\nimport \"../interfaces/ITokenAdapter.sol\";\nimport \"../libraries/LowGasSafeMath.sol\";\nimport \"../libraries/Fraction.sol\";\n\n\n\nlibrary RebalanceValidation {\n  using LowGasSafeMath for uint256;\n  using Fraction for uint256;\n\n  function validateSufficientImprovement(\n    uint256 currentAPR,\n    uint256 newAPR,\n    uint256 minImprovement\n  ) internal pure {\n    require(\n      newAPR.sub(currentAPR, \"!increased\").toFractionE18(currentAPR) >= minImprovement,\n      \"insufficient improvement\"\n    );\n  }\n\n  function validateProposedWeights(\n    uint256[] memory currentWeights,\n    uint256[] memory proposedWeights\n  ) internal pure {\n    uint256 len = currentWeights.length;\n    require(proposedWeights.length == len, \"bad lengths\");\n    uint256 _sum;\n    for (uint256 i; i < len; i++) {\n      uint256 weight = proposedWeights[i];\n      _sum = _sum.add(weight);\n      if (weight == 0) {\n        require(currentWeights[i] == 0, \"can not set null weight\");\n      } else {\n        require(weight >= 5e16, \"weight < 5%\");\n      }\n    }\n    require(_sum == 1e18, \"weights != 100%\");\n  }\n\n  function validateAdaptersAndWeights(\n    IAdapterRegistry registry,\n    address underlying,\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights\n  ) internal view {\n    uint256 len = adapters.length;\n    require(weights.length == len, \"bad lengths\");\n    uint256 totalWeight;\n    for (uint256 i; i < len; i++) {\n      IErc20Adapter adapter = adapters[i];\n      require(registry.isApprovedAdapter(address(adapter)), \"!approved\");\n      require(adapter.underlying() == underlying, \"bad adapter\");\n      for (uint256 j = i + 1; j < len; j++) {\n        require(address(adapter) != address(adapters[j]), \"duplicate adapter\");\n      }\n      uint256 weight = weights[i];\n      totalWeight = totalWeight.add(weight);\n      require(weight >= 5e16, \"weight < 5%\");\n    }\n    require(totalWeight == 1e18, \"weights != 100%\");\n  }\n}"
    },
    "contracts/vaults/NirnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../libraries/RebalanceValidation.sol\";\nimport \"../libraries/SafeCast.sol\";\nimport \"./NirnVaultBase.sol\";\n\n\ncontract NirnVault is NirnVaultBase {\n  using Fraction for uint256;\n  using TransferHelper for address;\n  using LowGasSafeMath for uint256;\n  using MinimalSignedMath for int256;\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using ArrayHelper for uint256[];\n  using ArrayHelper for bytes32[];\n  using ArrayHelper for IErc20Adapter[];\n  using DynamicArrays for uint256[];\n  using AdapterHelper for IErc20Adapter[];\n\n/* ========== Constructor ========== */\n\n  constructor(\n    address _registry,\n    address _eoaSafeCaller\n  ) NirnVaultBase(_registry, _eoaSafeCaller) {}\n\n/* ========== Liquidity Delta Queries ========== */\n\n  function getCurrentLiquidityDeltas() external view override returns (int256[] memory liquidityDeltas) {\n    (IErc20Adapter[] memory adapters, uint256[] memory weights) = getAdaptersAndWeights();\n    BalanceSheet memory balanceSheet = getBalanceSheet(adapters);\n    liquidityDeltas = AdapterHelper.getLiquidityDeltas(\n      balanceSheet.totalProductiveBalance,\n      balanceSheet.balances,\n      weights\n    );\n  }\n\n  function getHypotheticalLiquidityDeltas(\n    uint256[] memory proposedWeights\n  ) public view override returns (int256[] memory liquidityDeltas) {\n    (IErc20Adapter[] memory adapters,) = getAdaptersAndWeights();\n    require(proposedWeights.length == adapters.length, \"bad lengths\");\n    BalanceSheet memory balanceSheet = getBalanceSheet(adapters);\n    liquidityDeltas = AdapterHelper.getLiquidityDeltas(\n      balanceSheet.totalProductiveBalance,\n      balanceSheet.balances,\n      proposedWeights\n    );\n  }\n\n  function getHypotheticalLiquidityDeltas(\n    IErc20Adapter[] memory proposedAdapters,\n    uint256[] memory proposedWeights\n  ) external view override returns (int256[] memory liquidityDeltas) {\n    require(proposedAdapters.length == proposedWeights.length, \"bad lengths\");\n    liquidityDeltas = AdapterHelper.getLiquidityDeltas(\n      balance().mulSubFractionE18(reserveRatio),\n      proposedAdapters.getBalances(),\n      proposedWeights\n    );\n  }\n\n/* ========== APR Queries ========== */\n\n  function getAPR() external view override returns (uint256) {\n    (DistributionParameters memory params,,) = currentDistribution();\n    return params.netAPR;\n  }\n\n  function getAPRs() external view override returns (uint256[] memory aprs) {\n    (IErc20Adapter[] memory adapters, uint256[] memory weights) = getAdaptersAndWeights();\n    BalanceSheet memory balanceSheet = getBalanceSheet(adapters);\n    int256[] memory liquidityDeltas = AdapterHelper.getLiquidityDeltas(\n      balanceSheet.totalProductiveBalance,\n      balanceSheet.balances,\n      weights\n    );\n    uint256 len = adapters.length;\n    aprs = new uint256[](len);\n    for (uint256 i; i < len; i++) {\n      aprs[i] = adapters[i].getHypotheticalAPR(liquidityDeltas[i]);\n    }\n  }\n\n  function getHypotheticalAPR(uint256[] memory proposedWeights) external view override returns (uint256) {\n    (IErc20Adapter[] memory adapters,) = getAdaptersAndWeights();\n    require(proposedWeights.length == adapters.length, \"bad lengths\");\n    BalanceSheet memory balanceSheet = getBalanceSheet(adapters);\n    int256[] memory liquidityDeltas = AdapterHelper.getLiquidityDeltas(\n      balanceSheet.totalProductiveBalance,\n      balanceSheet.balances,\n      proposedWeights\n    );\n    return adapters.getNetAPR(proposedWeights, liquidityDeltas).mulSubFractionE18(reserveRatio);\n  }\n\n  function getHypotheticalAPR(\n    IErc20Adapter[] memory proposedAdapters,\n    uint256[] memory proposedWeights\n  ) external view override returns (uint256) {\n    require(proposedAdapters.length == proposedWeights.length, \"bad lengths\");\n    (IErc20Adapter[] memory adapters,) = getAdaptersAndWeights();\n    BalanceSheet memory balanceSheet = getBalanceSheet(adapters);\n    int256[] memory liquidityDeltas = AdapterHelper.getLiquidityDeltas(\n      balanceSheet.totalProductiveBalance,\n      proposedAdapters.getBalances(),\n      proposedWeights\n    );\n    return proposedAdapters.getNetAPR(\n      proposedWeights,\n      liquidityDeltas\n    ).mulSubFractionE18(reserveRatio);\n  }\n\n/* ========== Deposit/Withdraw ========== */\n\n  function deposit(uint256 amount) external override returns (uint256 shares) {\n    shares = depositTo(amount, msg.sender);\n  }\n\n  function depositTo(uint256 amount, address to) public override returns (uint256 shares) {\n    uint256 bal = balance();\n    uint256 max = maximumUnderlying;\n    if (max > 0) {\n      require(bal.add(amount) <= max, \"maximumUnderlying\");\n    }\n    underlying.safeTransferFrom(msg.sender, address(this), amount);\n    uint256 supply = claimFees(bal, totalSupply);\n    shares = supply == 0 ? amount : amount.mul(supply) / bal;\n    _mint(to, shares);\n    emit Deposit(shares, amount);\n  }\n\n  function withdraw(uint256 shares) external override returns (uint256 amountOut) {\n    (IErc20Adapter[] memory adapters, uint256[] memory weights) = getAdaptersAndWeights();\n    BalanceSheet memory balanceSheet = getBalanceSheet(adapters);\n    uint256 supply = claimFees(balanceSheet.totalBalance, totalSupply);\n    amountOut = shares.mul(balanceSheet.totalBalance) / supply;\n    withdrawInternal(\n      shares,\n      amountOut,\n      adapters,\n      weights,\n      balanceSheet\n    );\n  }\n\n  function withdrawUnderlying(uint256 amount) external override returns (uint256 shares) {\n    (IErc20Adapter[] memory adapters, uint256[] memory weights) = getAdaptersAndWeights();\n    BalanceSheet memory balanceSheet = getBalanceSheet(adapters);\n    uint256 supply = claimFees(balanceSheet.totalBalance, totalSupply);\n    shares = amount.mul(supply) / balanceSheet.totalBalance;\n    withdrawInternal(\n      shares,\n      amount,\n      adapters,\n      weights,\n      balanceSheet\n    );\n  }\n\n  function withdrawInternal(\n    uint256 shares,\n    uint256 amountOut,\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights,\n    BalanceSheet memory balanceSheet\n  ) internal {\n    _burn(msg.sender, shares);\n    emit Withdrawal(shares, amountOut);\n    uint256 newReserves = balanceSheet.totalBalance.sub(amountOut).mulFractionE18(reserveRatio);\n    withdrawToMatchAmount(\n      adapters,\n      weights,\n      balanceSheet.balances,\n      balanceSheet.reserveBalance,\n      amountOut,\n      newReserves\n    );\n    _transferOut(msg.sender, amountOut);\n  }\n\n  function withdrawToMatchAmount(\n    IErc20Adapter[] memory adapters,\n    uint256[] memory weights,\n    uint256[] memory balances,\n    uint256 _reserveBalance,\n    uint256 amount,\n    uint256 newReserves\n  ) internal {\n    if (amount > _reserveBalance) {\n      uint256 remainder = amount.sub(_reserveBalance);\n      uint256 len = balances.length;\n      uint256[] memory removeIndices = DynamicArrays.dynamicUint256Array(len);\n      for (uint256 i; i < len; i++) {\n        uint256 bal = balances[i];\n        if (bal == 0) continue;\n        // If the balance is sufficient to withdraw both the remainder and the new reserves,\n        // withdraw the remainder and the new reserves. Otherwise, withdraw the balance.\n        uint256 optimalWithdrawal = remainder.add(newReserves);\n        uint256 amountToWithdraw = bal > optimalWithdrawal\n          ? optimalWithdrawal\n          : bal;\n        uint256 amountWithdrawn = adapters[i].withdrawUnderlyingUpTo(amountToWithdraw);\n        remainder = remainder >= amountWithdrawn ? remainder - amountWithdrawn : 0;\n        if (weights[i] == 0 && amountWithdrawn == bal) {\n          removeIndices.dynamicPush(i);\n        }\n        if (remainder == 0) break;\n      }\n      require(remainder == 0, \"insufficient available balance\");\n      removeAdapters(removeIndices);\n    }\n  }\n\n/* ========== Rebalance Actions ========== */\n\n  function rebalance() external override onlyEOA {\n    (IErc20Adapter[] memory adapters, uint256[] memory weights) = getAdaptersAndWeights();\n    BalanceSheet memory balanceSheet = getBalanceSheet(adapters);\n    int256[] memory liquidityDeltas = AdapterHelper.getLiquidityDeltas(balanceSheet.totalProductiveBalance, balanceSheet.balances, weights);\n    uint256[] memory removedIndices = AdapterHelper.rebalance(\n      adapters,\n      weights,\n      liquidityDeltas,\n      balanceSheet.reserveBalance\n    );\n    removeAdapters(removedIndices);\n    emit Rebalanced();\n  }\n\n  function rebalanceWithNewWeights(uint256[] memory proposedWeights) external override onlyEOA {\n    (\n      DistributionParameters memory params,\n      uint256 totalProductiveBalance,\n      uint256 _reserveBalance\n    ) = currentDistribution();\n    RebalanceValidation.validateProposedWeights(params.weights, proposedWeights);\n    // Get liquidity deltas and APR for new weights\n    int256[] memory proposedLiquidityDeltas = AdapterHelper.getLiquidityDeltas(totalProductiveBalance, params.balances, proposedWeights);\n    uint256 proposedAPR = AdapterHelper.getNetAPR(params.adapters, proposedWeights, proposedLiquidityDeltas).mulSubFractionE18(reserveRatio);\n    // Validate rebalance results in sufficient APR improvement\n    RebalanceValidation.validateSufficientImprovement(params.netAPR, proposedAPR, minimumAPRImprovement);\n    // Rebalance and remove adapters with 0 weight which the vault could fully exit.\n    uint256[] memory removedIndices = AdapterHelper.rebalance(params.adapters, proposedWeights, proposedLiquidityDeltas, _reserveBalance);\n    uint256 removeLen = removedIndices.length;\n    if (removeLen > 0) {\n      for (uint256 i = removeLen; i > 0; i--) {\n        uint256 rI = removedIndices[i-1];\n        emit AdapterRemoved(params.adapters[rI]);\n        params.adapters.mremove(rI);\n        proposedWeights.mremove(rI);\n      }\n    }\n    setAdaptersAndWeights(params.adapters, proposedWeights);\n  }\n\n  struct DistributionParameters {\n    IErc20Adapter[] adapters;\n    uint256[] weights;\n    uint256[] balances;\n    int256[] liquidityDeltas;\n    uint256 netAPR;\n  }\n\n  function currentDistribution() internal view returns (\n    DistributionParameters memory params,\n    uint256 totalProductiveBalance,\n    uint256 _reserveBalance\n  ) {\n    uint256 _reserveRatio = reserveRatio;\n    (params.adapters, params.weights) = getAdaptersAndWeights();\n    uint256 len = params.adapters.length;\n    uint256 netAPR;\n    params.balances = params.adapters.getBalances();\n    _reserveBalance = reserveBalance();\n    totalProductiveBalance = params.balances.sum().add(_reserveBalance).mulSubFractionE18(_reserveRatio);\n    params.liquidityDeltas = new int256[](len);\n    for (uint256 i; i < len; i++) {\n      IErc20Adapter adapter = params.adapters[i];\n      uint256 weight = params.weights[i];\n      uint256 targetBalance = totalProductiveBalance.mulFractionE18(weight);\n      int256 liquidityDelta = targetBalance.toInt256().sub(params.balances[i].toInt256());\n      netAPR = netAPR.add(\n        adapter.getHypotheticalAPR(liquidityDelta).mulFractionE18(weight)\n      );\n      params.liquidityDeltas[i] = liquidityDelta;\n    }\n    params.netAPR = netAPR.mulSubFractionE18(_reserveRatio);\n  }\n\n  function processProposedDistribution(\n    DistributionParameters memory currentParams,\n    uint256 totalProductiveBalance,\n    IErc20Adapter[] calldata proposedAdapters,\n    uint256[] calldata proposedWeights\n  ) internal view returns (DistributionParameters memory params) {\n    uint256[] memory excludedAdapterIndices = currentParams.adapters.getExcludedAdapterIndices(proposedAdapters);\n    uint256 proposedSize = proposedAdapters.length;\n    uint256 expandedSize = proposedAdapters.length + excludedAdapterIndices.length;\n    params.adapters = new IErc20Adapter[](expandedSize);\n    params.weights = new uint256[](expandedSize);\n    params.balances = new uint256[](expandedSize);\n    params.liquidityDeltas = new int256[](expandedSize);\n    uint256 i;\n    uint256 netAPR;\n    for (; i < proposedSize; i++) {\n      IErc20Adapter adapter = proposedAdapters[i];\n      params.adapters[i] = adapter;\n      uint256 weight = proposedWeights[i];\n      params.weights[i] = weight;\n      uint256 targetBalance = totalProductiveBalance.mulFractionE18(weight);\n      uint256 _balance = adapter.balanceUnderlying();\n      params.balances[i] = _balance;\n      int256 liquidityDelta = targetBalance.toInt256().sub(_balance.toInt256());\n      netAPR = netAPR.add(\n        adapter.getHypotheticalAPR(liquidityDelta).mulFractionE18(weight)\n      );\n      params.liquidityDeltas[i] = liquidityDelta;\n    }\n    netAPR = netAPR.mulSubFractionE18(reserveRatio);\n    RebalanceValidation.validateSufficientImprovement(currentParams.netAPR, netAPR, minimumAPRImprovement);\n    for (; i < expandedSize; i++) {\n      // i - proposedSize = index in excluded adapter indices array\n      // The value in excludedAdapterIndices is the index in the current adapters array\n      // for the adapter which is being removed.\n      // The lending markets for these adapters may or may not have sufficient liquidity to\n      // process a full withdrawal requested by the vault, so we keep those adapters in the\n      // adapters list, but set a weight of 0 and a liquidity delta of -balance\n      uint256 rI = excludedAdapterIndices[i - proposedSize];\n      params.adapters[i] = currentParams.adapters[rI];\n      params.weights[i] = 0;\n      uint256 _balance = currentParams.balances[rI];\n      params.balances[i] = _balance;\n      params.liquidityDeltas[i] = -_balance.toInt256();\n    }\n  }\n\n  function rebalanceWithNewAdapters(\n    IErc20Adapter[] calldata proposedAdapters,\n    uint256[] calldata proposedWeights\n  ) external override onlyEOA {\n    RebalanceValidation.validateAdaptersAndWeights(registry, underlying, proposedAdapters, proposedWeights);\n    (\n      DistributionParameters memory currentParams,\n      uint256 totalProductiveBalance,\n      uint256 _reserveBalance\n    ) = currentDistribution();\n    DistributionParameters memory proposedParams = processProposedDistribution(\n      currentParams,\n      totalProductiveBalance,\n      proposedAdapters,\n      proposedWeights\n    );\n    beforeAddAdapters(proposedParams.adapters);\n    uint256[] memory removedIndices = AdapterHelper.rebalance(\n      proposedParams.adapters,\n      proposedParams.weights,\n      proposedParams.liquidityDeltas,\n      _reserveBalance\n    );\n    uint256 removedLen = removedIndices.length;\n    if (removedLen > 0) {\n      // The indices to remove are necessarily in ascending order, so as long as we remove\n      // them in reverse, the removal of elements will not break the other indices.\n      for (uint256 i = removedLen; i > 0; i--) {\n        uint256 rI = removedIndices[i-1];\n        emit AdapterRemoved(proposedParams.adapters[rI]);\n        proposedParams.adapters.mremove(rI);\n        proposedParams.weights.mremove(rI);\n      }\n    }\n    setAdaptersAndWeights(proposedParams.adapters, proposedParams.weights);\n  }\n\n  function _transferOut(address to, uint256 amount) internal {\n    underlying.safeTransfer(to, amount);\n  }\n}"
    },
    "contracts/NirnVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/IProxyManager.sol\";\nimport \"./interfaces/IAdapterRegistry.sol\";\nimport \"./interfaces/INirnVault.sol\";\nimport \"./libraries/ArrayHelper.sol\";\n\n\ncontract NirnVaultFactory is Ownable() {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using ArrayHelper for EnumerableSet.AddressSet;\n\n/* ========== Events ========== */\n\n  event TokenApproved(address token);\n\n  event SetDefaultRewardsSeller(address defaultRewardsSeller);\n\n  event SetDefaultFeeRecipient(address defaultFeeRecipient);\n\n/* ========== Constants ========== */\n\n  address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  uint256 public constant minimumAdapters = 2;\n  bytes32 public constant erc20VaultImplementationId = keccak256(\"NirnVault.sol\");\n  bytes32 public constant ethVaultImplementationId = keccak256(\"EthNirnVault.sol\");\n  IProxyManager public immutable proxyManager;\n  IAdapterRegistry public immutable registry;\n\n/* ========== Storage ========== */\n\n  EnumerableSet.AddressSet internal _approvedTokens;\n  address public defaultFeeRecipient;\n  address public defaultRewardsSeller;\n\n/* ========== Constructor ========== */\n\n  constructor(address _proxyManager, address _registry) {\n    proxyManager = IProxyManager(_proxyManager);\n    registry = IAdapterRegistry(_registry);\n  }\n\n/* ========== Configuration ========== */\n\n  function approveToken(address token) external onlyOwner {\n    require(!_approvedTokens.contains(token), \"already approved\");\n    require(token != address(0), \"null address\");\n    _approvedTokens.add(token);\n    emit TokenApproved(token);\n  }\n\n  function setDefaultRewardsSeller(address _defaultRewardsSeller) external onlyOwner {\n    require(_defaultRewardsSeller != address(0), \"null address\");\n    defaultRewardsSeller = _defaultRewardsSeller;\n    emit SetDefaultRewardsSeller(_defaultRewardsSeller);\n  }\n\n  function setDefaultFeeRecipient(address _defaultFeeRecipient) external onlyOwner {\n    require(_defaultFeeRecipient != address(0), \"null address\");\n    defaultFeeRecipient = _defaultFeeRecipient;\n    emit SetDefaultFeeRecipient(_defaultFeeRecipient);\n  }\n\n/* ========== Queries ========== */\n\n  function isTokenApproved(address token) external view returns (bool) {\n    return _approvedTokens.contains(token);\n  }\n\n  function getApprovedTokens() external view returns (address[] memory approvedTokens) {\n    approvedTokens = _approvedTokens.toArray();\n  }\n\n  function computeVaultAddress(address underlying) external view returns (address vault) {\n    bytes32 implementationId = getImplementationId(underlying);\n    bytes32 salt = keccak256(abi.encode(underlying));\n    vault = proxyManager.computeProxyAddressManyToOne(address(this), implementationId, salt);\n  }\n\n  function getImplementationId(address underlying) internal pure returns (bytes32 implementationId) {\n    return underlying == weth\n      ? ethVaultImplementationId\n      : erc20VaultImplementationId;\n  }\n\n/* ========== Actions ========== */\n\n  function deployVault(address underlying) external {\n    require(_approvedTokens.contains(underlying), \"!approved\");\n    require(registry.getAdaptersCount(underlying) >= minimumAdapters, \"insufficient adapters\");\n    address _defaultRewardsSeller = defaultRewardsSeller;\n    address _defaultFeeRecipient = defaultFeeRecipient;\n    require(\n      _defaultRewardsSeller != address(0) &&\n      _defaultFeeRecipient != address(0),\n      \"null default\"\n    );\n    bytes32 implementationId = getImplementationId(underlying);\n    bytes32 salt = keccak256(abi.encode(underlying));\n    address vault = proxyManager.deployProxyManyToOne(implementationId, salt);\n    INirnVault(vault).initialize(underlying, _defaultRewardsSeller, _defaultFeeRecipient, owner());\n    registry.addVault(vault);\n  }\n}"
    },
    "contracts/interfaces/IProxyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.10;\n\n\ninterface IProxyManager {\n  function deployProxyManyToOne(\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external returns(address proxyAddress);\n\n  function computeProxyAddressManyToOne(\n    address originator,\n    bytes32 implementationID,\n    bytes32 suppliedSalt\n  ) external view returns (address);\n}"
    },
    "contracts/test/TestArrayHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0;\n\nimport \"../libraries/ArrayHelper.sol\";\n\n\ncontract TestArrayHelper {\n  using ArrayHelper for uint256[];\n  using ArrayHelper for bytes32[];\n  using ArrayHelper for address[];\n  using ArrayHelper for IErc20Adapter[];\n  using ArrayHelper for EnumerableSet.AddressSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  EnumerableSet.AddressSet internal addressSet;\n  address[] internal addressArray;\n  bytes32[] internal bytes32Array;\n\n  function toArray() external view returns (address[] memory arr) {\n    arr = addressSet.toArray();\n  }\n\n  function setAddressSet(address[] memory arr) external {\n    for (uint256 i; i < arr.length; i++) addressSet.add(arr[i]);\n  }\n\n  function setAddressArray(address[] memory arr) external {\n    addressArray = arr;\n  }\n\n  function setBytes32Array(bytes32[] memory arr) external {\n    bytes32Array = arr;\n  }\n\n  function getAddressArray() external view returns (address[] memory arr) {\n    arr = addressArray;\n  }\n\n  function getBytes32Array() external view returns (bytes32[] memory arr) {\n    arr = bytes32Array;\n  }\n  function sum(uint256[] memory arr) external pure returns (uint256) {\n    return arr.sum();\n  }\n\n  function mremove(uint256[] memory arr, uint256 index) external pure returns (uint256[] memory) {\n    arr.mremove(index);\n    return arr;\n  }\n\n  function mremove(address[] memory arr, uint256 index) external pure returns (address[] memory) {\n    arr.mremove(index);\n    return arr;\n  }\n\n  function mremoveAdapters(IErc20Adapter[] memory arr, uint256 index) external pure returns (IErc20Adapter[] memory) {\n    arr.mremove(index);\n    return arr;\n  }\n\n  function removeBytes32(uint256 index) external {\n    bytes32Array.remove(index);\n  }\n\n  function removeAddress(uint256 index) external {\n    addressArray.remove(index);\n  }\n\n  function indexOf(address[] memory arr, address find) external pure returns (uint256) {\n    return arr.indexOf(find);\n  }\n\n  function sortByDescendingScore(\n    address[] memory addresses,\n    uint256[] memory scores\n  ) external pure returns (address[] memory, uint256[] memory) {\n    addresses.sortByDescendingScore(scores);\n    return (addresses, scores);\n  }\n}"
    },
    "contracts/protocols/DyDxProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../interfaces/DyDxInterfaces.sol\";\nimport \"../interfaces/IAdapterRegistry.sol\";\nimport \"../adapters/dydx/DyDxErc20Adapter.sol\";\nimport \"../adapters/dydx/DyDxEtherAdapter.sol\";\nimport \"../libraries/CloneLibrary.sol\";\nimport \"../libraries/ArrayHelper.sol\";\n\n\ncontract DyDxProtocolAdapter {\n  using ArrayHelper for address[];\n  using CloneLibrary for address;\n\n/* ========== Events ========== */\n\n  event MarketFrozen(address token);\n\n  event MarketUnfrozen(address token);\n\n  event AdapterFrozen(address adapter);\n\n  event AdapterUnfrozen(address adapter);\n\n/* ========== Constants ========== */\n\n  IDyDx public constant dydx = IDyDx(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n  IAdapterRegistry public immutable registry;\n  address public immutable erc20AdapterImplementation;\n\n/* ========== Storage ========== */\n\n  address[] public frozenAdapters;\n  DyDxMarket[] public frozenMarkets;\n  uint256 public totalMapped = 1;\n\n/* ========== Structs ========== */\n\n  struct DyDxMarket {\n    address underlying;\n    uint96 marketId;\n  }\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) {\n    registry = _registry;\n    erc20AdapterImplementation = address(new DyDxErc20Adapter());\n    _registry.addTokenAdapter(address(new DyDxEtherAdapter(0)));\n  }\n\n/* ========== Public Actions ========== */\n\n  function map(uint256 max) external {\n    address[] memory tokens = getUnmappedUpTo(max);\n    uint256 len = tokens.length;\n    uint256 prevLen = totalMapped;\n    address[] memory adapters = new address[](len);\n    uint256 skipped;\n    for (uint256 i; i < len; i++) {\n      uint96 marketId = uint96(prevLen + i);\n      address underlying = dydx.getMarketTokenAddress(marketId);\n      if (\n        underlying == 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359 ||\n        isTokenMarketFrozen(marketId)\n      ) {\n        frozenMarkets.push(DyDxMarket(underlying, marketId));\n        skipped++;\n        emit MarketFrozen(underlying);\n        continue;\n      }\n      address adapter = deployAdapter(underlying, marketId);\n      adapters[i - skipped] = adapter;\n    }\n    totalMapped = prevLen + len;\n    assembly { if gt(skipped, 0) { mstore(adapters, sub(len, skipped)) } }\n    registry.addTokenAdapters(adapters);\n  }\n\n  function unfreezeAdapter(uint256 index) external {\n    DyDxErc20Adapter adapter = DyDxErc20Adapter(frozenAdapters[index]);\n    uint256 marketId = adapter.marketId();\n    require(!isTokenMarketFrozen(marketId), \"Market not frozen\");\n    frozenAdapters.remove(index);\n    registry.addTokenAdapter(address(adapter));\n    emit AdapterUnfrozen(address(adapter));\n  }\n\n  function unfreezeToken(uint256 index) external {\n    DyDxMarket memory market = frozenMarkets[index];\n    uint256 marketId = market.marketId;\n    require(!isTokenMarketFrozen(marketId), \"Market not frozen\");\n    removeMarket(index);\n    address adapter = deployAdapter(market.underlying, marketId);\n    registry.addTokenAdapter(address(adapter));\n    emit MarketUnfrozen(market.underlying);\n  }\n\n  function freezeAdapter(address adapterAddress) external {\n    DyDxErc20Adapter adapter = DyDxErc20Adapter(adapterAddress);\n    uint256 marketId = adapter.marketId();\n    require(isTokenMarketFrozen(marketId), \"Market not frozen\");\n    frozenAdapters.push(adapterAddress);\n    registry.removeTokenAdapter(adapterAddress);\n    emit AdapterUnfrozen(address(adapter));\n  }\n\n/* ========== Internal Actions ========== */\n\n  function deployAdapter(address underlying, uint256 marketId) internal returns (address adapter) {\n    adapter = erc20AdapterImplementation.createClone();\n    DyDxErc20Adapter(adapter).initialize(underlying, marketId);\n  }\n\n  function removeMarket(uint256 index) internal {\n    uint256 len = frozenMarkets.length;\n    if (index == len - 1) {\n      frozenMarkets.pop();\n      return;\n    }\n    DyDxMarket memory last = frozenMarkets[len - 1];\n    frozenMarkets[index] = last;\n    frozenMarkets.pop();\n  }\n\n/* ========== Public Queries ========== */\n\n  function protocol() external pure returns (string memory) {\n    return \"DyDx\";\n  }\n\n  function frozenTokens(uint256 index) external view returns (address token) {\n    token = frozenMarkets[index].underlying;\n  }\n\n  function getUnmapped() public view returns (address[] memory tokens) {\n    tokens = getUnmappedUpTo(1e18);\n  }\n\n  function getUnmappedUpTo(uint256 max)\n    public\n    view\n    returns (address[] memory tokens)\n  {\n    uint256 numMarkets = dydx.getNumMarkets();\n    uint256 prevLen = totalMapped;\n    uint256 len = numMarkets - prevLen;\n    if (max < len) len = max;\n    tokens = new address[](len);\n    for (uint256 i; i < len; i++) {\n      uint256 marketId = prevLen + i;\n      address underlying = dydx.getMarketTokenAddress(marketId);\n      tokens[i] = underlying;\n    }\n  }\n\n  function getFrozenAdapters() external view returns (address[] memory tokens) {\n    tokens = frozenAdapters;\n  }\n\n  function getFrozenTokens() external view returns (address[] memory tokens) {\n    DyDxMarket[] memory markets = frozenMarkets;\n    uint256 len = markets.length;\n    tokens = new address[](len);\n    for (uint256 i; i < len; i++) tokens[i] = markets[i].underlying;\n  }\n\n/* ========== Internal Queries ========== */  \n\n  function isTokenMarketFrozen(uint256 marketId) internal view returns (bool) {\n    return dydx.getMarketIsClosing(marketId);\n  }\n}\n\n"
    },
    "contracts/interfaces/DyDxInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\npragma abicoder v2;\n\n\ninterface DyDxStructs {\n  struct Val {\n    uint256 value;\n  }\n\n  struct Set {\n    uint128 borrow;\n    uint128 supply;\n  }\n\n  enum ActionType {\n    Deposit, // supply tokens\n    Withdraw // borrow tokens\n  }\n\n  enum AssetDenomination {\n    Wei // the amount is denominated in wei\n  }\n\n  enum AssetReference {\n    Delta // the amount is given as a delta from the current value\n  }\n\n  struct AssetAmount {\n    bool sign; // true if positive\n    AssetDenomination denomination;\n    AssetReference ref;\n    uint256 value;\n  }\n\n  struct ActionArgs {\n    ActionType actionType;\n    uint256 accountId;\n    AssetAmount amount;\n    uint256 primaryMarketId;\n    uint256 secondaryMarketId;\n    address otherAddress;\n    uint256 otherAccountId;\n    bytes data;\n  }\n\n  struct Info {\n    address owner; // The address that owns the account\n    uint256 number; // A nonce that allows a single address to control many accounts\n  }\n\n  struct Wei {\n    bool sign; // true if positive\n    uint256 value;\n  }\n}\n\n\ninterface IDyDx is DyDxStructs {\n  function getEarningsRate() external view returns (Val memory);\n\n  function getNumMarkets() external view returns (uint256);\n\n  function getMarketIsClosing(uint256 marketId) external view returns (bool);\n\n  function getMarketTokenAddress(uint256) external view returns (address);\n\n  function getMarketInterestRate(uint256 marketId) external view returns (Val memory);\n\n  function getMarketTotalPar(uint256 marketId) external view returns (Set memory);\n\n  function getAccountWei(Info memory account, uint256 marketId) external view returns (Wei memory);\n\n  function operate(Info[] memory, ActionArgs[] memory) external;\n}\n"
    },
    "contracts/adapters/dydx/DyDxErc20Adapter.sol": {
      "content": "pragma abicoder v2;\n\nimport \"../../interfaces/ITokenAdapter.sol\";\nimport \"../../interfaces/DyDxInterfaces.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/SymbolHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport \"../../vaults/ERC20.sol\";\n\n\ncontract DyDxErc20Adapter is ERC20, DyDxStructs, IErc20Adapter {\n  using SymbolHelper for address;\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Constants ========== */\n\n  uint256 internal constant DECIMAL = 10 ** 18;\n  IDyDx public constant dydx = IDyDx(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n\n/* ========== Storage ========== */\n\n  address public override underlying;\n  uint96 public marketId;\n\n  function token() external view virtual override returns (address) {\n    return address(this);\n  }\n\n/* ========== Initializer ========== */\n\n  function initialize(address _underlying, uint256 _marketId) external virtual {\n    require(underlying == address(0), \"initialized\");\n    underlying = _underlying;\n    marketId = uint96(_marketId);\n    underlying.safeApproveMax(address(dydx));\n  }\n\n/* ========== Metadata ========== */\n\n  function name() external view virtual override returns (string memory) {\n    return string(abi.encodePacked(\n      \"DyDx \",\n      underlying.getSymbol(),\n      \" Adapter\"\n    ));\n  }\n\n  function balance() public view returns (uint256) {\n    Wei memory bal = dydx.getAccountWei(Info(address(this), 0), marketId);\n    return bal.value;\n  }\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(address(dydx));\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    uint256 bal = balance();\n    uint256 supply = totalSupply;\n    return supply == 0 ? underlyingAmount : (underlyingAmount.mul(supply) / bal);\n  }\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return tokenAmount.mul(balance()) / totalSupply;\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceWrapped() public view override returns (uint256) {\n    return balanceOf[msg.sender];\n  }\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return balanceOf[msg.sender].mul(balance()) / totalSupply;\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256 apr) {\n    uint256 _marketId = marketId;\n    uint256 rate = dydx.getMarketInterestRate(_marketId).value;\n    uint256 aprBorrow = rate * 31622400;\n    Set memory marketPar = dydx.getMarketTotalPar(_marketId);\n    uint256 borrow = marketPar.borrow;\n    uint256 supply = marketPar.supply;\n    uint256 usage = (borrow.mul(DECIMAL)) / supply;\n    apr = ((aprBorrow.mul(usage)) / DECIMAL).mul(dydx.getEarningsRate().value) / DECIMAL;\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\n    uint256 _marketId = marketId;\n    uint256 rate = dydx.getMarketInterestRate(_marketId).value;\n    uint256 aprBorrow = rate * 31622400;\n    Set memory marketPar = dydx.getMarketTotalPar(_marketId);\n    uint256 borrow = marketPar.borrow;\n    uint256 supply = uint256(dydx.getMarketTotalPar(_marketId).supply).add(liquidityDelta);\n    uint256 usage = (borrow.mul(DECIMAL)) / supply;\n    apr = ((aprBorrow.mul(usage)) / DECIMAL).mul(dydx.getEarningsRate().value) / DECIMAL;\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    override\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    assets = new address[](1);\n    aprs = new uint256[](1);\n    assets[0] = underlying;\n    aprs[0] = getAPR();\n  }\n\n/* ========== Token Actions ========== */\n\n  function deposit(uint256 amount) external override returns (uint256 shares) {\n    require(amount > 0, \"DyDx: Mint failed\");\n    shares = toWrappedAmount(amount);\n    underlying.safeTransferFrom(msg.sender, address(this), amount);\n    _mint(msg.sender, shares);\n    _deposit(amount);\n  }\n\n  function withdraw(uint256 shares) public virtual override returns (uint256 amountOut) {\n    require(shares > 0, \"DyDx: Burn failed\");\n    amountOut = toUnderlyingAmount(shares);\n    _burn(msg.sender, shares);\n    _withdraw(amountOut, true);\n  }\n\n  function withdrawAll() public virtual override returns (uint256 amountReceived) {\n    return withdraw(balanceOf[msg.sender]);\n  }\n\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual override returns (uint256 shares) {\n    require(amountUnderlying > 0, \"DyDx: Burn failed\");\n    shares = toWrappedAmount(amountUnderlying);\n    _burn(msg.sender, shares);\n    _withdraw(amountUnderlying, true);\n  }\n\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual override returns (uint256 amountReceived) {\n    uint256 available = availableLiquidity();\n    amountReceived = amountUnderlying >= available ? available : amountUnderlying;\n    _burn(msg.sender, toWrappedAmount(amountReceived));\n    _withdraw(amountUnderlying, true);\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _deposit(uint256 amount) internal {\n    Info[] memory infos = new Info[](1);\n    infos[0] = Info(address(this), 0);\n\n    AssetAmount memory amt = AssetAmount(true, AssetDenomination.Wei, AssetReference.Delta, amount);\n    ActionArgs memory act;\n    act.actionType = ActionType.Deposit;\n    act.accountId = 0;\n    act.amount = amt;\n    act.primaryMarketId = marketId;\n    act.otherAddress = address(this);\n\n    ActionArgs[] memory args = new ActionArgs[](1);\n    args[0] = act;\n\n    dydx.operate(infos, args);\n  }\n\n  function _withdraw(uint256 amount, bool toUser) internal {\n    Info[] memory infos = new Info[](1);\n    infos[0] = Info(address(this), 0);\n\n    AssetAmount memory amt = AssetAmount(false, AssetDenomination.Wei, AssetReference.Delta, amount);\n    ActionArgs memory act;\n    act.actionType = ActionType.Withdraw;\n    act.accountId = 0;\n    act.amount = amt;\n    act.primaryMarketId = marketId;\n    act.otherAddress = toUser ? msg.sender : address(this);\n\n    ActionArgs[] memory args = new ActionArgs[](1);\n    args[0] = act;\n\n    dydx.operate(infos, args);\n  }\n}"
    },
    "contracts/adapters/dydx/DyDxEtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./DyDxErc20Adapter.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\n\n\ncontract DyDxEtherAdapter is DyDxErc20Adapter, IEtherAdapter {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Constructor & Initializer ========== */\n\n  constructor(uint96 _marketId) {\n    underlying = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    marketId = _marketId;\n    underlying.safeApproveMax(address(dydx));\n  }\n\n  function initialize(address, uint256) external virtual override {\n    return;\n  }\n\n/* ========== Metadata Queries ========== */\n\n  function name() external pure override(DyDxErc20Adapter, IErc20Adapter) returns (string memory) {\n    return \"DyDx ETH Adapter\";\n  }\n\n/* ========== Token Actions ========== */\n\n  function depositETH() external payable virtual override returns (uint256 shares) {\n    require(msg.value > 0, \"DyDx: Mint failed\");\n    shares = toWrappedAmount(msg.value);\n    IWETH(underlying).deposit{value: msg.value}();\n    _mint(msg.sender, shares);\n    _deposit(msg.value);\n  }\n\n  function withdrawAsETH(uint256 shares) public virtual override returns (uint256 amountOut) {\n    amountOut = toUnderlyingAmount(shares);\n    _burn(msg.sender, shares);\n    _withdraw(amountOut, false);\n    IWETH(underlying).withdraw(amountOut);\n    address(msg.sender).safeTransferETH(amountOut);\n  }\n\n  function withdrawAllAsETH() external virtual override returns (uint256 amountReceived) {\n    return withdrawAsETH(balanceWrapped());\n  }\n\n  function withdrawUnderlyingAsETH(uint256 amountUnderlying) external virtual override returns (uint256 shares) {\n    require(amountUnderlying > 0, \"DyDx: Burn failed\");\n    shares = toWrappedAmount(amountUnderlying);\n    _burn(msg.sender, shares);\n    _withdraw(amountUnderlying, false);\n    IWETH(underlying).withdraw(amountUnderlying);\n    address(msg.sender).safeTransferETH(amountUnderlying);\n  }\n}"
    },
    "contracts/test/TestProxyManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../interfaces/IProxyManager.sol\";\nimport \"../libraries/CloneLibrary.sol\";\n\n\ncontract TestProxyManager is IProxyManager {\n  event DeployedProxy(bytes32 implementationId, address proxy);\n\n  mapping (bytes32 => address) public implementations;\n\n  function addImplementation(bytes32 implementationId, address implementation) external {\n    implementations[implementationId] = implementation;\n  }\n\n  function deployProxyManyToOne(bytes32 implementationId, bytes32 suppliedSalt) external override returns (address proxy) {\n    bytes32 salt = keccak256(abi.encode(implementationId, suppliedSalt));\n    proxy = CloneLibrary.createClone(implementations[implementationId], salt);\n    emit DeployedProxy(implementationId, proxy);\n  }\n\n  function computeProxyAddressManyToOne(\n    address, bytes32 implementationId, bytes32 suppliedSalt\n  ) external view override returns (address proxy) {\n    bytes32 salt = keccak256(abi.encode(implementationId, suppliedSalt));\n    address implementation = implementations[implementationId];\n    bytes32 initCodeHash = keccak256(CloneLibrary.getCreateCode(implementation));\n    bytes32 _data = keccak256(\n      abi.encodePacked(bytes1(0xff), address(this), salt, initCodeHash)\n    );\n    return address(uint160(uint256(_data)));\n  }\n}"
    },
    "contracts/test/TestFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\nimport \"../libraries/CloneLibrary.sol\";\n\n\ncontract TestFactory {\n  address public last;\n  function clone(address implementation) external {\n    last = CloneLibrary.createClone(implementation);\n  }\n}"
    },
    "contracts/adapters/fulcrum/FulcrumEtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../../interfaces/ITokenAdapter.sol\";\nimport \"../../interfaces/FulcrumInterfaces.sol\";\nimport \"../../interfaces/IERC20Metadata.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\n\n\ncontract FulcrumEtherAdapter is IEtherAdapter {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Constants ========== */\n\n  IBZX public constant bzx = IBZX(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n  uint256 internal constant weiPercentPrecision = 1e20;\n\n  address public override underlying;\n\n  address public override token;\n\n/* ========== Constructor & Initializer ========== */\n\n  constructor(address _underlying, address _token) {\n    underlying = _underlying;\n    token = _token;\n    _underlying.safeApproveMax(token);\n  }\n\n/* ========== Metadata ========== */\n\n  string public override name = \"Fulcrum ETH Adapter\";\n\n  function availableLiquidity() public view override returns (uint256) {\n    (,,,uint256 interestUnPaid, uint256 interestFeePercent,) = bzx.getLenderInterestData(\n      token,\n      underlying\n    );\n\n    interestUnPaid = interestUnPaid\n      .mul(weiPercentPrecision.sub(interestFeePercent))\n      / weiPercentPrecision;\n    return IERC20(underlying).balanceOf(token).add(interestUnPaid);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return tokenAmount.mul(IToken(token).tokenPrice()) / uint256(1e18);\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount.mul(1e18) / IToken(token).tokenPrice();\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256 apr) {\n    return IToken(token).supplyInterestRate() / 100;\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\n    IToken iToken = IToken(token);\n    return iToken.totalSupplyInterestRate(\n      iToken.totalAssetSupply().add(liquidityDelta)\n    ) / 100;\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    override\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    assets = new address[](1);\n    aprs = new uint256[](1);\n    assets[0] = underlying;\n    aprs[0] = getAPR();\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceWrapped() external view virtual override returns (uint256) {\n    return IERC20(token).balanceOf(msg.sender);\n  }\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return IToken(token).assetBalanceOf(msg.sender);\n  }\n\n/* ========== Token Actions ========== */\n\n  function deposit(uint256 amountUnderlying) external virtual override returns (uint256 amountMinted) {\n    underlying.safeTransferFrom(msg.sender, address(this), amountUnderlying);\n    amountMinted = IToken(token).mint(msg.sender, amountUnderlying);\n    require(amountMinted > 0, \"IToken: Mint failed\");\n  }\n\n  function depositETH() external payable virtual override returns (uint256 amountMinted) {\n    amountMinted = IToken(token).mintWithEther{value: msg.value}(msg.sender);\n    require(amountMinted > 0, \"IToken: Mint failed\");\n  }\n\n  function withdraw(uint256 amountToken) external virtual override returns (uint256 amountReceived) {\n    token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = IToken(token).burn(msg.sender, amountToken);\n    require(amountReceived > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawAsETH(uint256 amountToken) external virtual override returns (uint256 amountReceived) {\n    token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = IToken(token).burnToEther(msg.sender, amountToken);\n    require(amountReceived > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawAll() external virtual override returns (uint256 amountReceived) {\n    uint256 amountToken = IERC20(token).balanceOf(msg.sender);\n    token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = IToken(token).burn(msg.sender, amountToken);\n    require(amountReceived > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawAllAsETH() external virtual override returns (uint256 amountReceived) {\n    uint256 amountToken = IERC20(token).balanceOf(msg.sender);\n    token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = IToken(token).burnToEther(msg.sender, amountToken);\n    require(amountReceived > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\n    amountBurned = amountUnderlying.mul(1e18).divCeil(IToken(token).tokenPrice());\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(IToken(token).burn(msg.sender, amountBurned) > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawUnderlyingAsETH(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\n    amountBurned = amountUnderlying.mul(1e18).divCeil(IToken(token).tokenPrice());\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(IToken(token).burnToEther(msg.sender, amountBurned) > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual override returns (uint256 amountReceived) {\n    uint256 amountAvailable = availableLiquidity();\n    amountReceived = amountAvailable < amountUnderlying ? amountAvailable : amountUnderlying;\n    uint256 amountBurned = amountReceived.mul(1e18) / IToken(token).tokenPrice();\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(IToken(token).burn(msg.sender, amountBurned) > 0, \"IToken: Burn failed\");\n  }\n}"
    },
    "contracts/protocols/FulcrumProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/FulcrumInterfaces.sol\";\nimport \"../adapters/fulcrum/FulcrumErc20Adapter.sol\";\nimport \"../adapters/fulcrum/FulcrumEtherAdapter.sol\";\nimport \"../interfaces/IAdapterRegistry.sol\";\nimport \"./AbstractProtocolAdapter.sol\";\n\n\ncontract FulcrumProtocolAdapter is AbstractProtocolAdapter {\n\n/* ========== Constants ========== */\n\n  IBZX public constant bzx = IBZX(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n  address public immutable erc20AdapterImplementation;\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) AbstractProtocolAdapter(_registry) {\n    address _erc20AdapterImplementation = address(new FulcrumErc20Adapter());\n    erc20AdapterImplementation = _erc20AdapterImplementation;\n\n    address[] memory loanPoolsZeroAndOne = bzx.getLoanPoolsList(0, 2);\n    address underlying0 = bzx.loanPoolToUnderlying(loanPoolsZeroAndOne[0]);\n    address adapter0 = CloneLibrary.createClone(_erc20AdapterImplementation);\n    FulcrumErc20Adapter(adapter0).initialize(underlying0, loanPoolsZeroAndOne[0]);\n\n    _registry.addTokenAdapter(adapter0);\n    _registry.addTokenAdapter(address(new FulcrumEtherAdapter(weth, loanPoolsZeroAndOne[1])));\n\n    totalMapped = 2;\n  }\n\n/* ========== Internal Actions ========== */\n\n  function deployAdapter(address loanPool) internal virtual override returns (address adapter) {\n    address underlying = bzx.loanPoolToUnderlying(loanPool);\n    adapter = CloneLibrary.createClone(erc20AdapterImplementation);\n    FulcrumErc20Adapter(adapter).initialize(underlying, loanPool);\n  }\n\n/* ========== Public Queries ========== */\n\n  function protocol() external pure virtual override returns (string memory) {\n    return \"Fulcrum\";\n  }\n\n  function getUnmapped() public view virtual override returns (address[] memory loanPools) {\n    loanPools = bzx.getLoanPoolsList(totalMapped, 1e18);\n  }\n\n  function getUnmappedUpTo(uint256 max) public view virtual override returns (address[] memory loanPools) {\n    loanPools = bzx.getLoanPoolsList(totalMapped, max);\n  }\n\n/* ========== Internal Queries ========== */\n\n  function isAdapterMarketFrozen(address adapter) internal view virtual override returns (bool) {\n    return isTokenMarketFrozen(IErc20Adapter(adapter).token());\n  }\n\n  function isTokenMarketFrozen(address loanPool) internal view virtual override returns (bool) {\n    return IERC20(loanPool).totalSupply() == 0;\n  }\n}"
    },
    "contracts/adapters/fulcrum/FulcrumErc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../../interfaces/ITokenAdapter.sol\";\nimport \"../../interfaces/FulcrumInterfaces.sol\";\nimport \"../../interfaces/IERC20Metadata.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/SymbolHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\n\n\ncontract FulcrumErc20Adapter is IErc20Adapter {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n  using SymbolHelper for address;\n\n/* ========== Constants ========== */\n\n  IBZX internal constant bzx = IBZX(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n  uint256 internal constant weiPercentPrecision = 1e20;\n\n/* ========== Storage ========== */\n\n  address public override underlying;\n\n  address public override token;\n\n/* ========== Initializer ========== */\n\n  function initialize(address _underlying, address _token) public virtual {\n    require(underlying == address(0) && token == address(0), \"initialized\");\n    require(_underlying != address(0) && _token != address(0), \"bad address\");\n    underlying = _underlying;\n    token = _token;\n    _underlying.safeApproveMax(token);\n  }\n\n/* ========== Metadata ========== */\n\n  function name() external view override returns (string memory) {\n    return string(abi.encodePacked(\n      \"Fulcrum \",\n      underlying.getSymbol(),\n      \" Adapter\"\n    ));\n  }\n\n  function availableLiquidity() public view override returns (uint256) {\n    (,,,uint256 interestUnPaid, uint256 interestFeePercent,) = bzx.getLenderInterestData(\n      token,\n      underlying\n    );\n\n    interestUnPaid = interestUnPaid\n      .mul(weiPercentPrecision.sub(interestFeePercent))\n      / weiPercentPrecision;\n    return IERC20(underlying).balanceOf(token).add(interestUnPaid);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return tokenAmount.mul(IToken(token).tokenPrice()) / uint256(1e18);\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount.mul(1e18) / IToken(token).tokenPrice();\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256 apr) {\n    return IToken(token).supplyInterestRate() / 100;\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\n    IToken iToken = IToken(token);\n    return iToken.totalSupplyInterestRate(\n      iToken.totalAssetSupply().add(liquidityDelta)\n    ) / 100;\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    override\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    assets = new address[](1);\n    aprs = new uint256[](1);\n    assets[0] = underlying;\n    aprs[0] = getAPR();\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceWrapped() external view virtual override returns (uint256) {\n    return IERC20(token).balanceOf(msg.sender);\n  }\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return IToken(token).assetBalanceOf(msg.sender);\n  }\n\n/* ========== Token Actions ========== */\n\n  function deposit(uint256 amountUnderlying) external virtual override returns (uint256 amountMinted) {\n    underlying.safeTransferFrom(msg.sender, address(this), amountUnderlying);\n    amountMinted = IToken(token).mint(msg.sender, amountUnderlying);\n    require(amountMinted > 0, \"IToken: Mint failed\");\n  }\n\n  function withdraw(uint256 amountToken) external virtual override returns (uint256 amountReceived) {\n    address _token = token;\n    _token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = IToken(_token).burn(msg.sender, amountToken);\n    require(amountReceived > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawAll() external virtual override returns (uint256 amountReceived) {\n    address _token = token;\n    uint256 amountToken = IERC20(_token).balanceOf(msg.sender);\n    _token.safeTransferFrom(msg.sender, address(this), amountToken);\n    amountReceived = IToken(_token).burn(msg.sender, amountToken);\n    require(amountReceived > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawUnderlying(uint256 amountUnderlying) external virtual override returns (uint256 amountBurned) {\n    amountBurned = amountUnderlying.mul(1e18).divCeil(IToken(token).tokenPrice());\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(IToken(token).burn(msg.sender, amountBurned) > 0, \"IToken: Burn failed\");\n  }\n\n  function withdrawUnderlyingUpTo(uint256 amountUnderlying) external virtual override returns (uint256 amountReceived) {\n    uint256 amountAvailable = availableLiquidity();\n    amountReceived = amountAvailable < amountUnderlying ? amountAvailable : amountUnderlying;\n    uint256 amountBurned = amountReceived.mul(1e18) / IToken(token).tokenPrice();\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(IToken(token).burn(msg.sender, amountBurned) > 0, \"IToken: Burn failed\");\n  }\n}"
    },
    "contracts/test/TestComptrollerLens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../interfaces/CompoundInterfaces.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n\ncontract TestComptrollerLens {\n  IComptroller internal constant comptroller = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n  IERC20 internal constant comp = IERC20(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n\n  function getPendingRewards(address account, address cToken) external returns (uint256) {\n    uint256 compBefore = comp.balanceOf(account);\n    address[] memory holders = new address[](1);\n    address[] memory cTokens = new address[](1);\n    holders[0] = account;\n    cTokens[0] = cToken;\n    comptroller.claimComp(holders, cTokens, false, true);\n    uint256 compAfter = comp.balanceOf(account);\n    return compAfter - compBefore;\n  }\n}"
    },
    "contracts/protocols/CompoundProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/CompoundInterfaces.sol\";\nimport \"../adapters/compound/C1Erc20Adapter.sol\";\nimport \"../adapters/compound/CErc20Adapter.sol\";\nimport \"../adapters/compound/CEtherAdapter.sol\";\nimport \"./AbstractProtocolAdapter.sol\";\n\n\ncontract CompoundProtocolAdapter is AbstractProtocolAdapter {\n  using CloneLibrary for address;\n\n/* ========== Constants ========== */\n\n  IComptroller public constant comptroller = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n  address public constant interestRateModelV1 = 0xBAE04CbF96391086dC643e842b517734E214D698;\n  address public immutable erc20AdapterImplementationV1;\n  address public immutable erc20AdapterImplementation;\n  address public immutable etherAdapterImplementation;\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) AbstractProtocolAdapter(_registry) {\n    erc20AdapterImplementationV1 = address(new C1Erc20Adapter());\n    erc20AdapterImplementation = address(new CErc20Adapter());\n    etherAdapterImplementation = address(new CEtherAdapter());\n  }\n\n/* ========== Internal Actions ========== */\n\n  function deployAdapter(address cToken) internal virtual override returns (address adapter) {\n    address underlying;\n    // The call to underlying() will use all the gas sent if it fails,\n    // so we specify a maximum of 25k gas. The contract will only use ~2k\n    // but this protects against all likely changes to the gas schedule.\n    try ICToken(cToken).underlying{gas: 25000}() returns (address _underlying) {\n      underlying = _underlying;\n      if (underlying == address(0)) {\n        underlying = weth;\n      }\n    } catch {\n      underlying = weth;\n    }\n    if (underlying == weth) {\n      adapter = etherAdapterImplementation.createClone();\n    } else if (address(ICToken(cToken).interestRateModel()) == interestRateModelV1) {\n      adapter = erc20AdapterImplementationV1.createClone();\n    } else {\n      adapter = erc20AdapterImplementation.createClone();\n    }\n    CErc20Adapter(adapter).initialize(underlying, cToken);\n  }\n\n/* ========== Public Queries ========== */\n\n  function protocol() external pure virtual override returns (string memory) {\n    return \"Compound\";\n  }\n\n  function getUnmapped() public view virtual override returns (address[] memory cTokens) {\n    cTokens = toAddressArray(comptroller.getAllMarkets());\n    uint256 len = cTokens.length;\n    uint256 prevLen = totalMapped;\n    if (len == prevLen) {\n      assembly { mstore(cTokens, 0) }\n    } else {\n      assembly {\n        cTokens := add(cTokens, mul(prevLen, 32))\n        mstore(cTokens, sub(len, prevLen))\n      }\n    }\n  }\n\n  function toAddressArray(ICToken[] memory cTokens) internal pure returns (address[] memory arr) {\n    assembly { arr := cTokens }\n  }\n\n/* ========== Internal Queries ========== */\n\n  function isAdapterMarketFrozen(address adapter) internal view virtual override returns (bool) {\n    return isTokenMarketFrozen(IErc20Adapter(adapter).token());\n  }\n\n  function isTokenMarketFrozen(address cToken) internal view virtual override returns (bool) {\n    if (comptroller.mintGuardianPaused(cToken)) {\n      return true;\n    }\n    return IERC20(cToken).totalSupply() == 0;\n  }\n}"
    },
    "contracts/adapters/compound/C1Erc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractErc20Adapter.sol\";\nimport \"../../interfaces/CompoundInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { C1TokenParams } from \"../../libraries/C1TokenParams.sol\";\n\n\ncontract C1Erc20Adapter is AbstractErc20Adapter() {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Constants ========== */\n\n  IComptroller internal constant comptroller = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n  address internal constant cComp = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4;\n  address internal constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"Compound\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(token);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return (\n      tokenAmount\n      .mul(C1TokenParams.currentExchangeRate(token))\n      / uint256(1e18)\n    );\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount\n      .mul(1e18)\n      / C1TokenParams.currentExchangeRate(token);\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getRewardsAPR(\n    ICToken cToken,\n    uint256 _totalLiquidity\n  ) internal view returns (uint256) {\n    IPriceOracle oracle = comptroller.oracle();\n    uint256 compPrice = oracle.getUnderlyingPrice(cComp);\n    uint256 tokenPrice = oracle.getUnderlyingPrice(address(cToken));\n    if (compPrice == 0 || tokenPrice == 0) return 0;\n    uint256 annualRewards = comptroller.compSpeeds(address(cToken)).mul(2102400).mul(compPrice);\n    return annualRewards.mul(1e18) / _totalLiquidity.mul(tokenPrice);\n  }\n\n  function getRewardsAPR() public view returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      ,uint256 cash,\n      uint256 borrows,\n      uint256 reserves,\n    ) = C1TokenParams.getInterestRateParametersV1(address(cToken));\n\n    uint256 totalLiquidity = cash.add(borrows).sub(reserves);\n    cToken.getCash().add(cToken.totalBorrows()).sub(cToken.totalReserves());\n    return getRewardsAPR(ICToken(token), totalLiquidity);\n  }\n\n  function getAPR() public view virtual override returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = C1TokenParams.getInterestRateParametersV1(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(borrowsPrior).sub(reservesPrior);\n    uint256 baseAPR = C1TokenParams.computeSupplyRateV1(\n      model,\n      cashPrior,\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa,\n      0\n    );\n    uint256 rewardsAPR = getRewardsAPR(cToken, liquidityTotal);\n    return baseAPR.add(rewardsAPR);\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = C1TokenParams.getInterestRateParametersV1(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(borrowsPrior).sub(reservesPrior);\n    uint256 baseAPR = C1TokenParams.computeSupplyRateV1(\n      model,\n      cashPrior,\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa,\n      liquidityDelta\n    );\n    uint256 rewardsAPR = getRewardsAPR(cToken, liquidityTotal.add(liquidityDelta));\n    return baseAPR.add(rewardsAPR);\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    override\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = C1TokenParams.getInterestRateParametersV1(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(borrowsPrior).sub(reservesPrior);\n    uint256 baseAPR = C1TokenParams.computeSupplyRateV1(\n      model,\n      cashPrior,\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa,\n      0\n    );\n    uint256 rewardsAPR = getRewardsAPR(cToken, liquidityTotal);\n    uint256 size = rewardsAPR > 0 ? 2 : 1;\n    assets = new address[](size);\n    aprs = new uint256[](size);\n    assets[0] = underlying;\n    aprs[0] = baseAPR;\n    if (rewardsAPR > 0) {\n      assets[1] = comp;\n      aprs[1] = rewardsAPR;\n    }\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return toUnderlyingAmount(ICToken(token).balanceOf(msg.sender));\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _claimRewardsIfAny(address account) internal {\n    address[] memory holders = new address[](1);\n    address[] memory cTokens = new address[](1);\n    holders[0] = account;\n    cTokens[0] = token;\n    comptroller.claimComp(holders, cTokens, false, true);\n  }\n\n  function _approve() internal virtual override {\n    underlying.safeApproveMax(token);\n  }\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    address _token = token;\n    require(ICToken(_token).mint(amountUnderlying) == 0, \"CErc20: Mint failed\");\n    amountMinted = IERC20(_token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(ICToken(token).redeem(amountToken) == 0, \"CErc20: Burn failed\");\n    amountReceived = IERC20(underlying).balanceOf(address(this));\n    _claimRewardsIfAny(msg.sender);\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = toWrappedAmount(amountUnderlying);\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(ICToken(token).redeemUnderlying(amountUnderlying) == 0, \"CErc20: Burn failed\");\n    _claimRewardsIfAny(msg.sender);\n  }\n}"
    },
    "contracts/adapters/compound/CErc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractErc20Adapter.sol\";\nimport \"../../interfaces/CompoundInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { CTokenParams } from \"../../libraries/CTokenParams.sol\";\n\n\ncontract CErc20Adapter is AbstractErc20Adapter() {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Constants ========== */\n\n  IComptroller internal constant comptroller = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n  address internal constant cComp = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4;\n  address internal constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"Compound\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(token);\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return (\n      tokenAmount\n      .mul(CTokenParams.currentExchangeRate(token))\n      / uint256(1e18)\n    );\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount\n      .mul(1e18)\n      / CTokenParams.currentExchangeRate(token);\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getRewardsAPR(\n    ICToken cToken,\n    uint256 _totalLiquidity\n  ) internal view returns (uint256) {\n    IPriceOracle oracle = comptroller.oracle();\n    uint256 compPrice = oracle.getUnderlyingPrice(cComp);\n    uint256 tokenPrice = oracle.getUnderlyingPrice(address(cToken));\n    if (compPrice == 0 || tokenPrice == 0) return 0;\n    uint256 annualRewards = comptroller.compSpeeds(address(cToken)).mul(2102400).mul(compPrice);\n    return annualRewards.mul(1e18) / _totalLiquidity.mul(tokenPrice);\n  }\n\n  function getRewardsAPR() public view returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      ,uint256 cash,\n      uint256 borrows,\n      uint256 reserves,\n    ) = CTokenParams.getInterestRateParameters(address(cToken));\n\n    uint256 totalLiquidity = cash.add(borrows).sub(reserves);\n    cToken.getCash().add(cToken.totalBorrows()).sub(cToken.totalReserves());\n    return getRewardsAPR(ICToken(token), totalLiquidity);\n  }\n\n  function getAPR() public view virtual override returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = CTokenParams.getInterestRateParameters(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(borrowsPrior).sub(reservesPrior);\n\n    return IInterestRateModel(model).getSupplyRate(\n      cashPrior,\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa\n    ).mul(2102400).add(getRewardsAPR(cToken, liquidityTotal));\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = CTokenParams.getInterestRateParameters(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(liquidityDelta).add(borrowsPrior).sub(reservesPrior);\n\n    return IInterestRateModel(model).getSupplyRate(\n      cashPrior.add(liquidityDelta),\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa\n    ).mul(2102400).add(getRewardsAPR(cToken, liquidityTotal));\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    override\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = CTokenParams.getInterestRateParameters(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(borrowsPrior).sub(reservesPrior);\n    uint256 baseAPR = IInterestRateModel(model).getSupplyRate(\n      cashPrior,\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa\n    ).mul(2102400);\n    uint256 rewardsAPR = getRewardsAPR(cToken, liquidityTotal);\n    uint256 size = rewardsAPR > 0 ? 2 : 1;\n    assets = new address[](size);\n    aprs = new uint256[](size);\n    assets[0] = underlying;\n    aprs[0] = baseAPR;\n    if (rewardsAPR > 0) {\n      assets[1] = comp;\n      aprs[1] = rewardsAPR;\n    }\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return toUnderlyingAmount(ICToken(token).balanceOf(msg.sender));\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _claimRewardsIfAny(address account) internal {\n    address[] memory holders = new address[](1);\n    address[] memory cTokens = new address[](1);\n    holders[0] = account;\n    cTokens[0] = token;\n    comptroller.claimComp(holders, cTokens, false, true);\n  }\n\n  function _approve() internal virtual override {\n    underlying.safeApproveMax(token);\n  }\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    address _token = token;\n    require(ICToken(_token).mint(amountUnderlying) == 0, \"CErc20: Mint failed\");\n    amountMinted = IERC20(_token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(ICToken(token).redeem(amountToken) == 0, \"CErc20: Burn failed\");\n    amountReceived = IERC20(underlying).balanceOf(address(this));\n    _claimRewardsIfAny(msg.sender);\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = toWrappedAmount(amountUnderlying);\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(ICToken(token).redeemUnderlying(amountUnderlying) == 0, \"CErc20: Burn failed\");\n    _claimRewardsIfAny(msg.sender);\n  }\n}"
    },
    "contracts/adapters/compound/CEtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractEtherAdapter.sol\";\nimport \"../../interfaces/CompoundInterfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport { C1TokenParams } from \"../../libraries/C1TokenParams.sol\";\n\n\ncontract CEtherAdapter is AbstractEtherAdapter() {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/* ========== Constants ========== */\n\n  IComptroller internal comptroller = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n  address internal constant cComp = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4;\n  address internal constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"Compound\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return address(token).balance;\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) public view override returns (uint256) {\n    return (\n      tokenAmount\n      .mul(C1TokenParams.currentExchangeRate(token))\n      / uint256(1e18)\n    );\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) public view override returns (uint256) {\n    return underlyingAmount\n      .mul(1e18)\n      / C1TokenParams.currentExchangeRate(token);\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getRewardsAPR(\n    ICToken cToken,\n    uint256 _totalLiquidity\n  ) internal view returns (uint256) {\n    IPriceOracle oracle = comptroller.oracle();\n    uint256 compPrice = oracle.getUnderlyingPrice(cComp);\n    uint256 tokenPrice = oracle.getUnderlyingPrice(address(cToken));\n    if (compPrice == 0 || tokenPrice == 0) return 0;\n    uint256 annualRewards = comptroller.compSpeeds(address(cToken)).mul(2102400).mul(compPrice);\n    return annualRewards.mul(1e18) / _totalLiquidity.mul(tokenPrice);\n  }\n\n  function getRewardsAPR() public view returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      ,uint256 cash,\n      uint256 borrows,\n      uint256 reserves,\n    ) = C1TokenParams.getInterestRateParametersV1(address(cToken));\n\n    uint256 totalLiquidity = cash.add(borrows).sub(reserves);\n    cToken.getCash().add(cToken.totalBorrows()).sub(cToken.totalReserves());\n    return getRewardsAPR(ICToken(token), totalLiquidity);\n  }\n\n  function getAPR() public view virtual override returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = C1TokenParams.getInterestRateParametersV1(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(borrowsPrior).sub(reservesPrior);\n    uint256 baseAPR = C1TokenParams.computeSupplyRateV1(\n      model,\n      cashPrior,\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa,\n      0\n    );\n    uint256 rewardsAPR = getRewardsAPR(cToken, liquidityTotal);\n    return baseAPR.add(rewardsAPR);\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256) {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = C1TokenParams.getInterestRateParametersV1(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(borrowsPrior).sub(reservesPrior);\n    uint256 baseAPR = C1TokenParams.computeSupplyRateV1(\n      model,\n      cashPrior,\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa,\n      liquidityDelta\n    );\n    uint256 rewardsAPR = getRewardsAPR(cToken, liquidityTotal.add(liquidityDelta));\n    return baseAPR.add(rewardsAPR);\n  }\n\n  function getRevenueBreakdown()\n    external\n    view\n    override\n    returns (\n      address[] memory assets,\n      uint256[] memory aprs\n    )\n  {\n    ICToken cToken = ICToken(token);\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = C1TokenParams.getInterestRateParametersV1(address(cToken));\n    uint256 liquidityTotal = cashPrior.add(borrowsPrior).sub(reservesPrior);\n    uint256 baseAPR = C1TokenParams.computeSupplyRateV1(\n      model,\n      cashPrior,\n      borrowsPrior,\n      reservesPrior,\n      reserveFactorMantissa,\n      0\n    );\n    uint256 rewardsAPR = getRewardsAPR(cToken, liquidityTotal);\n    uint256 size = rewardsAPR > 0 ? 2 : 1;\n    assets = new address[](size);\n    aprs = new uint256[](size);\n    assets[0] = underlying;\n    aprs[0] = baseAPR;\n    if (rewardsAPR > 0) {\n      assets[1] = comp;\n      aprs[1] = rewardsAPR;\n    }\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return toUnderlyingAmount(ICToken(token).balanceOf(msg.sender));\n  }\n\n/* ========== Internal Ether Handlers ========== */\n  \n  // Convert to WETH if contract takes WETH\n  function _afterReceiveETH(uint256 amount) internal virtual override {}\n\n  // Convert to WETH if contract takes ETH\n  function _afterReceiveWETH(uint256 amount) internal virtual override {\n    IWETH(underlying).withdraw(amount);\n  }\n\n  // Convert to ETH if contract returns WETH\n  function _beforeSendETH(uint256 amount) internal virtual override {}\n\n  // Convert to WETH if contract returns ETH\n  function _beforeSendWETH(uint256 amount) internal virtual override {\n    IWETH(underlying).deposit{value: amount}();\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _claimRewardsIfAny(address account) internal {\n    address[] memory holders = new address[](1);\n    address[] memory cTokens = new address[](1);\n    holders[0] = account;\n    cTokens[0] = token;\n    comptroller.claimComp(holders, cTokens, false, true);\n  }\n\n  function _approve() internal virtual override {}\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    address _token = token;\n    ICToken(_token).mint{value: amountUnderlying}();\n    amountMinted = IERC20(_token).balanceOf(address(this));\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    require(ICToken(token).redeem(amountToken) == 0, \"CEther: Burn failed\");\n    amountReceived = address(this).balance;\n    _claimRewardsIfAny(msg.sender);\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    amountBurned = toWrappedAmount(amountUnderlying);\n    token.safeTransferFrom(msg.sender, address(this), amountBurned);\n    require(ICToken(token).redeemUnderlying(amountUnderlying) == 0, \"CErc20: Burn failed\");\n    _claimRewardsIfAny(msg.sender);\n  }\n}"
    },
    "contracts/libraries/C1TokenParams.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../interfaces/CompoundInterfaces.sol\";\nimport \"./LowGasSafeMath.sol\";\nimport \"./MinimalSignedMath.sol\";\n\n\nlibrary C1TokenParams {\n  using LowGasSafeMath for uint256;\n  using MinimalSignedMath for uint256;\n\n  uint256 internal constant EXP_SCALE = 1e18;\n  uint256 internal constant HALF_EXP_SCALE = 5e17;\n\n  function getInterestRateParametersV1(address token) internal view returns (\n    address model,\n    uint256 cashPrior,\n    uint256 borrowsPrior,\n    uint256 reservesPrior,\n    uint256 reserveFactorMantissa\n  ) {\n    ICToken cToken = ICToken(token);\n    model = address(cToken.interestRateModel());\n    cashPrior = cToken.getCash();\n    borrowsPrior = cToken.totalBorrows();\n    reservesPrior = cToken.totalReserves();\n    uint256 accrualBlockNumber = cToken.accrualBlockNumber();\n    reserveFactorMantissa = cToken.reserveFactorMantissa();\n    if (block.number > accrualBlockNumber) {\n      uint256 blockDelta = block.number - accrualBlockNumber;\n      uint256 pendingBorrowRate = getBorrowRate(model, cashPrior, borrowsPrior, reservesPrior);\n      uint256 interestAccumulated = mulScalarTruncate(pendingBorrowRate.mul(blockDelta), borrowsPrior);\n      borrowsPrior = borrowsPrior.add(interestAccumulated);\n      reservesPrior = mulScalarTruncate(reserveFactorMantissa, interestAccumulated).add(reservesPrior);\n    }\n  }\n\n  function computeSupplyRateV1(\n    address model,\n    uint256 cashPrior,\n    uint256 borrowsPrior,\n    uint256 reservesPrior,\n    uint256 reserveFactorMantissa,\n    int256 liquidityDelta\n  ) internal view returns (uint256) {\n    uint256 underlying = cashPrior.add(liquidityDelta).add(borrowsPrior).sub(reservesPrior).mul(1e18);\n    uint256 borrowsPer = divScalarByExp(borrowsPrior, underlying);\n    uint256 borrowRateMantissa = getBorrowRate(model, cashPrior, borrowsPrior, reservesPrior);\n    uint256 oneMinusReserveFactor = EXP_SCALE.sub(reserveFactorMantissa);\n    return mulExp3(borrowRateMantissa, oneMinusReserveFactor, borrowsPer);\n  }\n\n  function getSupplyRateV1(address token, int256 liquidityDelta) internal view returns (uint256) {\n    (\n      address model,\n      uint256 cashPrior,\n      uint256 borrowsPrior,\n      uint256 reservesPrior,\n      uint256 reserveFactorMantissa\n    ) = getInterestRateParametersV1(token);\n    uint256 underlying = cashPrior.add(liquidityDelta).add(borrowsPrior).sub(reservesPrior).mul(1e18);\n    uint256 borrowsPer = divScalarByExp(borrowsPrior, underlying);\n    uint256 borrowRateMantissa = getBorrowRate(model, cashPrior, borrowsPrior, reservesPrior);\n    uint256 oneMinusReserveFactor = EXP_SCALE.sub(reserveFactorMantissa);\n    return mulExp3(borrowRateMantissa, oneMinusReserveFactor, borrowsPer);\n  }\n\n  function currentExchangeRate(address token) internal view returns (uint256 exchangeRate) {\n    ICToken cToken = ICToken(token);\n    uint256 blockDelta = block.number - cToken.accrualBlockNumber();\n    if (blockDelta == 0) {\n      return cToken.exchangeRateStored();\n    }\n\n    IInterestRateModel model = cToken.interestRateModel();\n\n    uint256 cashPrior = cToken.getCash();\n    uint256 borrowsPrior = cToken.totalBorrows();\n    uint256 reservesPrior = cToken.totalReserves();\n    uint256 reserveFactorMantissa = cToken.reserveFactorMantissa();\n    if (blockDelta > 0) {\n      uint256 borrowRateMantissa = getBorrowRate(address(model), cashPrior, borrowsPrior, reservesPrior);\n      uint256 interestAccumulated = mulScalarTruncate(borrowRateMantissa.mul(blockDelta), borrowsPrior);\n      borrowsPrior = borrowsPrior.add(interestAccumulated);\n      reservesPrior = mulScalarTruncate(reserveFactorMantissa, interestAccumulated).add(reservesPrior);\n    }\n\n    return cashPrior.add(borrowsPrior).sub(reservesPrior).mul(1e18) / ICToken(token).totalSupply();\n  }\n  \n\n  function truncate(uint256 x) internal pure returns (uint256) {\n    return x / EXP_SCALE;\n  }\n\n  function mulScalarTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n    return truncate(x.mul(y));\n  }\n\n  function mulScalarTruncateAddUInt(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\n    return mulScalarTruncate(x, y).add(z);\n  }\n\n  function divScalarByExp(uint256 scalar, uint256 exp) internal pure returns (uint256) {\n    uint256 numerator = scalar.mul(EXP_SCALE);\n    return numerator.mul(EXP_SCALE) / exp;\n  }\n\n  function mulExp(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 doubleScaledProduct = a.mul(b);\n    uint256 doubleScaledProductWithHalfScale = HALF_EXP_SCALE.add(doubleScaledProduct);\n    return doubleScaledProductWithHalfScale / EXP_SCALE;\n  }\n\n  function mulExp3(uint256 a, uint256 b, uint256 c) internal pure returns (uint256) {\n    uint256 ab = mulExp(a, b);\n    return mulExp(ab, c);\n  }\n\n  function getBorrowRate(\n    address model,\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) internal view returns (uint256 borrowRateMantissa) {\n    (bool success, bytes memory retData) = model.staticcall(\n      abi.encodeWithSelector(\n        IInterestRateModel.getBorrowRate.selector,\n        cash,\n        borrows,\n        reserves\n      )\n    );\n    if (!success) revert(abi.decode(retData, (string)));\n    assembly {\n      switch lt(mload(retData), 64)\n      case 0 {borrowRateMantissa := mload(add(retData, 64))}\n      default {borrowRateMantissa := mload(add(retData, 32))}\n    }\n  }\n}"
    },
    "contracts/adapters/aave-v1/AaveV1EtherAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractEtherAdapter.sol\";\nimport \"../../interfaces/AaveV1Interfaces.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport \"../../libraries/RayDiv.sol\";\n\n\ncontract AaveV1EtherAdapter is AbstractEtherAdapter {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using RayDiv for uint256;\n  using TransferHelper for address;\n\n/* ========== Constants ========== */\n\n  address public constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n/* ========== Constants ========== */\n\n  ILendingPool public immutable pool;\n  ILendingPoolCore public immutable core;\n\n/* ========== Constructor ========== */\n\n  constructor(ILendingPoolAddressesProvider _aave) {\n    pool = _aave.getLendingPool();\n    core = _aave.getLendingPoolCore();\n  }\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"Aave V1\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return address(core).balance;\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) external view virtual override returns (uint256) {\n    return tokenAmount;\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) external view virtual override returns (uint256) {\n    return underlyingAmount;\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256 apr) {\n    apr = core.getReserveCurrentLiquidityRate(ETH_RESERVE_ADDRESS) / 1e9;\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\n    (uint256 liquidityRate,,) = core.getReserveInterestRateStrategyAddress(ETH_RESERVE_ADDRESS).calculateInterestRates(\n      ETH_RESERVE_ADDRESS,\n      core.getReserveAvailableLiquidity(ETH_RESERVE_ADDRESS).add(liquidityDelta),\n      core.getReserveTotalBorrowsStable(ETH_RESERVE_ADDRESS),\n      core.getReserveTotalBorrowsVariable(ETH_RESERVE_ADDRESS),\n      core.getReserveCurrentAverageStableBorrowRate(ETH_RESERVE_ADDRESS)\n    );\n    return liquidityRate / 1e9;\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return IERC20(token).balanceOf(msg.sender);\n  }\n\n/* ========== Internal Ether Handlers ========== */\n  \n  // Convert to WETH if contract takes WETH\n  function _afterReceiveETH(uint256 amount) internal virtual override {}\n\n  // Convert to WETH if contract takes ETH\n  function _afterReceiveWETH(uint256 amount) internal virtual override {\n    IWETH(underlying).withdraw(amount);\n  }\n\n  // Convert to ETH if contract returns WETH\n  function _beforeSendETH(uint256 amount) internal virtual override {}\n\n  // Convert to WETH if contract returns ETH\n  function _beforeSendWETH(uint256 amount) internal virtual override {\n    IWETH(underlying).deposit{value: amount}();\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual override {}\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    amountMinted = amountUnderlying;\n    pool.deposit{value: amountUnderlying}(ETH_RESERVE_ADDRESS, amountUnderlying, 0);\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    amountReceived = amountToken;\n    IAToken(token).redeem(amountToken);\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    token.safeTransferFrom(msg.sender, address(this), amountUnderlying);\n    amountBurned = amountUnderlying;\n    IAToken(token).redeem(amountUnderlying);\n  }\n}"
    },
    "contracts/libraries/RayDiv.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\nimport \"./LowGasSafeMath.sol\";\n\n\nlibrary RayDiv {\n  using LowGasSafeMath for uint256;\n  uint256 internal constant RAY = 1e27;\n\n\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n    return halfB.add(a.mul(RAY)) / b;\n  }\n}"
    },
    "contracts/protocols/AaveV1ProtocolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/AaveV1Interfaces.sol\";\nimport \"../adapters/aave-v1/AaveV1Erc20Adapter.sol\";\nimport \"../adapters/aave-v1/AaveV1EtherAdapter.sol\";\nimport \"./AbstractProtocolAdapter.sol\";\n\n\ncontract AaveV1ProtocolAdapter is AbstractProtocolAdapter {\n  using CloneLibrary for address;\n\n/* ========== Constants ========== */\n\n  ILendingPoolAddressesProvider public constant aave = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n  ILendingPoolCore public immutable core;\n  address public constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public immutable erc20AdapterImplementation;\n  address public immutable etherAdapterImplementation;\n\n/* ========== Constructor ========== */\n\n  constructor(IAdapterRegistry _registry) AbstractProtocolAdapter(_registry) {\n    core = aave.getLendingPoolCore();\n    erc20AdapterImplementation = address(new AaveV1Erc20Adapter(aave));\n    etherAdapterImplementation = address(new AaveV1EtherAdapter(aave));\n  }\n\n/* ========== Internal Actions ========== */\n\n  function deployAdapter(address underlying) internal virtual override returns (address adapter) {\n    if (underlying == ETH_RESERVE_ADDRESS) {\n      adapter = etherAdapterImplementation.createClone();\n      AaveV1EtherAdapter(payable(adapter)).initialize(weth, core.getReserveATokenAddress(underlying));\n    } else {\n      adapter = erc20AdapterImplementation.createClone();\n      AaveV1Erc20Adapter(adapter).initialize(underlying, core.getReserveATokenAddress(underlying));\n    }\n  }\n\n/* ========== Public Queries ========== */\n\n  function protocol() external pure virtual override returns (string memory) {\n    return \"Aave V1\";\n  }\n\n  function getUnmapped() public view virtual override returns (address[] memory tokens) {\n    tokens = core.getReserves();\n    uint256 len = tokens.length;\n    uint256 prevLen = totalMapped;\n    if (len == prevLen) {\n      assembly { mstore(tokens, 0) }\n    } else {\n      assembly {\n        tokens := add(tokens, mul(prevLen, 32))\n        mstore(tokens, sub(len, prevLen))\n      }\n    }\n  }\n\n/* ========== Internal Queries ========== */\n\n  function isAdapterMarketFrozen(address adapter) internal view virtual override returns (bool) {\n    return isTokenMarketFrozen(IErc20Adapter(adapter).underlying());\n  }\n\n  function isTokenMarketFrozen(address underlying) internal view virtual override returns (bool) {\n    return core.getReserveIsFreezed(underlying);\n  }\n}\n\n"
    },
    "contracts/adapters/aave-v1/AaveV1Erc20Adapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../AbstractErc20Adapter.sol\";\nimport \"../../interfaces/AaveV1Interfaces.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../../libraries/LowGasSafeMath.sol\";\nimport \"../../libraries/TransferHelper.sol\";\nimport \"../../libraries/MinimalSignedMath.sol\";\nimport \"../../libraries/RayDiv.sol\";\n\n\ncontract AaveV1Erc20Adapter is AbstractErc20Adapter {\n  using MinimalSignedMath for uint256;\n  using LowGasSafeMath for uint256;\n  using RayDiv for uint256;\n  using TransferHelper for address;\n\n/* ========== Constants ========== */\n\n  // ILendingPoolAddressesProvider public immutable aave;\n  ILendingPool public immutable pool;\n  ILendingPoolCore public immutable core;\n\n/* ========== Constructor ========== */\n\n  constructor(ILendingPoolAddressesProvider _aave) {\n    pool = _aave.getLendingPool();\n    core = _aave.getLendingPoolCore();\n  }\n\n/* ========== Internal Queries ========== */\n\n  function _protocolName() internal view virtual override returns (string memory) {\n    return \"Aave V1\";\n  }\n\n/* ========== Metadata ========== */\n\n  function availableLiquidity() public view override returns (uint256) {\n    return IERC20(underlying).balanceOf(address(core));\n  }\n\n/* ========== Conversion Queries ========== */\n\n  function toUnderlyingAmount(uint256 tokenAmount) external view virtual override returns (uint256) {\n    return tokenAmount;\n  }\n\n  function toWrappedAmount(uint256 underlyingAmount) external view virtual override returns (uint256) {\n    return underlyingAmount;\n  }\n\n/* ========== Performance Queries ========== */\n\n  function getAPR() public view virtual override returns (uint256 apr) {\n    apr = core.getReserveCurrentLiquidityRate(underlying) / 1e9;\n  }\n\n  function getHypotheticalAPR(int256 liquidityDelta) external view virtual override returns (uint256 apr) {\n    address reserve = underlying;\n    (uint256 liquidityRate,,) = core.getReserveInterestRateStrategyAddress(reserve).calculateInterestRates(\n      reserve,\n      core.getReserveAvailableLiquidity(reserve).add(liquidityDelta),\n      core.getReserveTotalBorrowsStable(reserve),\n      core.getReserveTotalBorrowsVariable(reserve),\n      core.getReserveCurrentAverageStableBorrowRate(reserve)\n    );\n    return liquidityRate / 1e9;\n  }\n\n/* ========== Caller Balance Queries ========== */\n\n  function balanceUnderlying() external view virtual override returns (uint256) {\n    return IERC20(token).balanceOf(msg.sender);\n  }\n\n/* ========== Internal Actions ========== */\n\n  function _approve() internal virtual override {\n    underlying.safeApproveMax(address(core));\n  }\n\n  function _mint(uint256 amountUnderlying) internal virtual override returns (uint256 amountMinted) {\n    amountMinted = amountUnderlying;\n    pool.deposit(underlying, amountUnderlying, 0);\n  }\n\n  function _burn(uint256 amountToken) internal virtual override returns (uint256 amountReceived) {\n    amountReceived = amountToken;\n    IAToken(token).redeem(amountToken);\n  }\n\n  function _burnUnderlying(uint256 amountUnderlying) internal virtual override returns (uint256 amountBurned) {\n    token.safeTransferFrom(msg.sender, address(this), amountUnderlying);\n    amountBurned = amountUnderlying;\n    IAToken(token).redeem(amountUnderlying);\n  }\n}"
    },
    "contracts/test/TestNirnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../vaults/NirnVault.sol\";\n\n\ncontract TestNirnVault is NirnVault {\n  constructor(\n    address _registry,\n    address _eoaSafeCaller\n  ) NirnVault(_registry, _eoaSafeCaller) {}\n\n  function setAdaptersAndWeightsInternal(\n    IErc20Adapter[] calldata adapters,\n    uint256[] calldata weights\n  ) external {\n    beforeAddAdapters(adapters);\n    setAdaptersAndWeights(adapters, weights);\n  }\n\n  function removeAdaptersInternal(uint256[] calldata removeIndices) external {\n    removeAdapters(removeIndices);\n  }\n\n  function withdrawToMatchAmountInternal(\n    IErc20Adapter[] calldata adapters,\n    uint256[] calldata weights,\n    uint256[] calldata balances,\n    uint256 _reserveBalance,\n    uint256 amount,\n    uint256 newReserves\n  ) external {\n    return withdrawToMatchAmount(\n      adapters,\n      weights,\n      balances,\n      _reserveBalance,\n      amount,\n      newReserves\n    );\n  }\n\n  function currentDistributionInternal() external view returns (\n    DistributionParameters memory params,\n    uint256 totalProductiveBalance,\n    uint256 _reserveBalance\n  ) {\n    return currentDistribution();\n  }\n\n  function balanceSheetInternal() external view returns (BalanceSheet memory) {\n    (IErc20Adapter[] memory adapters,) = getAdaptersAndWeights();\n    return getBalanceSheet(adapters);\n  }\n\n  function processProposedDistributionInternal(\n    DistributionParameters calldata currentParams,\n    uint256 totalProductiveBalance,\n    IErc20Adapter[] calldata proposedAdapters,\n    uint256[] calldata proposedWeights\n  ) external view returns (DistributionParameters memory params) {\n    return processProposedDistribution(\n      currentParams,\n      totalProductiveBalance,\n      proposedAdapters,\n      proposedWeights\n    );\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}